<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Game Programming Patterns / Design Patterns Revisited / Singleton</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');

</script>
</head>
<body id="top">
<div class="content">

<h1 class="book"><a href="index.html">Game Programming Patterns</a> / Design Patterns Revisited</h1>
<h1>Singleton</h1>
<p>This chapter is an anomaly. Every other chapter in this book shows
you how to use a design pattern. This chapter shows you how <em>not</em> to use
one.</p>
<p>Despite noble intentions, the <a class="gof-pattern"
href="http://c2.com/cgi/wiki?SingletonPattern">Singleton</a> pattern
described by the Gang of Four usually does more harm than good. While
they stress that the pattern should be used sparingly, that message
was often lost in translation to the <span name="instance">game industry</span>. Like any pattern,
though, using it where it doesn't belong is about as helpful as
treating a bullet wound with a splint. Since it's so overused, most
of this chapter will be about <em>avoiding</em> Singletons, but first, let's
go over the pattern itself.</p>
<aside name="instance">

<p>When much of the industry moved to object-oriented programming from C, one
problem they ran into was "how do I get an instance?" They had some method they
wanted to call, but didn't have an instance of the object that provides that
method in hand. Singletons (in other words, making it global) was an easy way out.</p>
</aside>

<h2><a href="#the-singleton-pattern" name="the-singleton-pattern">The Singleton Pattern</a></h2>
<p><em>Design Patterns</em> summarizes Singleton like this:</p>
<blockquote>
<p>Ensure a class has one instance, and provide a global point of
access to it.</p>
</blockquote>
<p>We'll split that at &ldquo;and&rdquo; and consider each half
separately.</p>
<h3><a href="#restricting-a-class-to-one-instance" name="restricting-a-class-to-one-instance">Restricting a class to one instance</a></h3>
<p>There are times when a class cannot perform correctly if there is more
than one instance of it. The common case is when the class interacts
with an external system that maintains its own global state.</p>
<p>Consider a class that wraps an underlying file system API. Because
file operations can take a while to complete, our class performs
operations asynchronously. This means multiple operations can be
running concurrently, so they must be coordinated with each other. If
we start one call to create a file, and another one to delete that
same file, our wrapper needs to be aware of both to make sure they
don't interfere with each other.</p>
<p>To do this, a call into our wrapper needs to have access to every
previous operation. If users could freely create instances of our
class, one instance has no way of knowing about operations that other
instances started. Enter the Singleton. It provides a way for a class
to ensure at compile time that there is only a single instance of the
class.</p>
<h3><a href="#providing-a-global-point-of-access" name="providing-a-global-point-of-access">Providing a global point of access</a></h3>
<p>Several different systems in the game will use our file system
wrapper: logging, content loading, game state saving, etc. If those
systems can't create their own instances of our file system wrapper,
how do they get ahold of one?</p>
<p>Singleton provides a solution to this too. In addition to creating the
single instance, it also provides a globally-available method to get
it. This way, anyone anywhere can get their paws on our blessed
instance. All together, the textbook implementation looks like this:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">static</span> <span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Lazy initialize.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">instance_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">instance_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileSystem</span><span class="p">();</span>

    <span class="k">return</span> <span class="o">*</span><span class="n">instance_</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">static</span> <span class="n">FileSystem</span> <span class="o">*</span><span class="n">instance_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The static <code>instance_</code> member holds an instance of the class, and the
private constructor ensures that it is the <em>only</em> one. The public
static <code>instance()</code> method grants access to the instance from anywhere
in the codebase. It is also responsible for creating the instance
using lazy initialization: it instantiates the Singleton the first
time someone asks for it.</p>
<h2><a href="#why-we-use-it" name="why-we-use-it">Why We Use It</a></h2>
<p>It seems we have a winner. Our file system wrapper is available
wherever we need it without the tedium of passing it around
everywhere. The class itself cleverly ensures we won't make a mess of
things by instantiating a couple of instances. It's got some other
nice features too:</p>
<ul>
<li>
<p><strong>It doesn't create the instance if no one uses it.</strong> Saving
    memory and CPU cycles is always good. Since the Singleton is
    initialized only when it's first accessed, if it won't be
    instantiated at all if the game never asks for it.</p>
</li>
<li>
<p><strong>It's initialized at runtime.</strong> A common alternative to Singleton
    is a class with static member variables. I like simple solutions,
    so I use static classes instead of Singletons when possible, but
    there's one limitation static members have: automatic
    initialization. The compiler initializes statics before <code>main()</code>
    is called. This means they can't use information known only once
    the program is up and running (for example, configuration
    information loaded from a file). It also means they can't reliably
    depend on each other&mdash; the compiler does not guarantee the
    order in which statics are initialized relative to each other.</p>
<p>Lazy initialization solves both of those problems. The Singleton
will be initialized as late as possible, so by that time any
information it needs should be available. As long as they don't
have circular dependencies, one Singleton can even refer to
another when initializing itself.</p>
</li>
<li>
<p><strong>You can subclass the Singleton.</strong> This is a powerful but often
    overlooked capability. Let's say we need our file system wrapper
    to be cross-platform. To make this work, we want it to be an
    abstract interface for a file system, with subclasses that
    implement the interface for each platform. Here are the basic
    classes:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">IFileSystem</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span>  <span class="n">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PS3FileSystem</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IFileSystem</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span>
  <span class="p">{</span> 
    <span class="c1">// Use Sony file IO API...</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Use sony file IO API...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WiiFileSystem</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IFileSystem</span>
<span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span>
  <span class="p">{</span> 
    <span class="c1">// Use Nintendo file IO API...</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span>  <span class="n">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Use Nintendo file IO API...</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>Now we turn <code>IFileSystem</code> into a Singleton:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">IFileSystem</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">static</span> <span class="n">IFileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">();</span>

  <span class="k">virtual</span> <span class="kt">char</span><span class="o">*</span> <span class="n">readFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span>  <span class="n">writeFile</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">contents</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">protected:</span>
  <span class="n">IFileSystem</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">static</span> <span class="n">IFileSystem</span> <span class="o">*</span><span class="n">instance_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The clever part is how the instance is created:</p>
<div class="codehilite"><pre><span class="n">IFileSystem</span><span class="o">&amp;</span> <span class="n">IFileSystem</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">instance_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="err">#</span><span class="k">if</span> <span class="n">PLATFORM</span> <span class="o">==</span> <span class="n">PLAYSTATION3</span>
      <span class="n">instance_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PS3FileSystem</span><span class="p">();</span>
    <span class="err">#</span><span class="n">elif</span> <span class="n">PLATFORM</span> <span class="o">==</span> <span class="n">WII</span>
      <span class="n">instance_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WiiFileSystem</span><span class="p">();</span>
    <span class="err">#</span><span class="n">endif</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">*</span><span class="n">instance_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>With a simple compiler switch, we bind our file system wrapper to
the appropriate concrete type. Our entire codebase can access the
file system using <code>IFileSystem::instance()</code> without being coupled
to any platform-specific code. That coupling is instead
encapsulated within the implementation file for the <code>IFileSystem</code>
class itself.</p>
</li>
</ul>
<p>This takes us about as far as most of us go when it comes to solving a
problem like this. We've got a file system wrapper. It works reliably.
It's available globally so every place that needs it can get to it.
It's time to check in the code and celebrate with a tasty beverage.</p>
<h2><a href="#why-we-regret-using-it" name="why-we-regret-using-it">Why We Regret Using It</a></h2>
<p>In the short-term, the Singleton pattern is relatively benign. Like
many design choices, we pay the cost in the long-term. Once we've cast
a few unnecessary Singletons into cold hard code, here's the trouble
we've bought ourselves:</p>
<h3><a href="#it's-a-global-variable" name="it's-a-global-variable">It's a global variable</a></h3>
<p>When games were still written by a couple of guys in a garage, pushing
the hardware was more important than ivory-tower software engineering
principles. Old-school C and assembly coders used globals and statics
without any trouble, and shipped good games. As games got bigger and
more complex, architecture and maintainability started to become the
bottleneck. We struggled to ship games not because of hardware
limitations, but because of <em>productivity</em> limitations.</p>
<p>So we moved to languages like C++ and started applying some of the
hard-earned wisdom of our software engineer forebears. One lesson we
learned is that global variables are bad, for a variety of reasons:</p>
<ul>
<li>
<p><strong>They make it harder to reason about code.</strong> Say we're
    tracking down a bug in a function someone else wrote. If that
    function doesn't touch any global state,
    we can wrap our heads around it just by understanding the body of
    the <span name="pure">function</span> and the arguments being passed to it.</p>
<aside name="pure">

<p>Computer scientists call functions that don't access or modify global
state &ldquo;pure&rdquo; functions. Pure functions are easier to
reason about, easier for the compiler to optimize, and let you do neat
things like memoization where you cache and reuse the results from
previous calls to the function.</p>
<p>While there are challenges to using purity exclusively, the benefits
are enticing enough that computer scientists have created languages
like Haskell that <em>only</em> allow pure functions.</p>
</aside>

<p>Now imagine right in the middle of that function is a call to
<code>SomeClass::getSomeGlobalData()</code>. Now to figure out what's going
on, we have to hunt through the entire codebase to see what
touches that global data. You don't really hate global state until
you've had to <code>grep</code> a million lines of code at three in the
morning trying to find the one errant call that's setting a static
variable to the wrong value.</p>
</li>
<li>
<p><strong>They encourage coupling.</strong> The new coder on your team isn't
    familiar with your game's beautifully maintainable loosely-coupled
    architecture, but he's just been given his first task: make
    boulders play sounds when they crash onto the ground. You and I
    know we don't want the physics code to be coupled to <em>audio</em> of
    all things, but he's just trying to get his task done.
    Unfortunately for us, the instance of our <code>AudioPlayer</code> is
    globally visible. So, one little <code>#include</code> later, our new guy has
    compromised a carefully constructed architecture.</p>
<p>Without a global instance of the audio player, even if he <em>did</em>
<code>#include</code> the header, he still wouldn't be able to do anything
with it. That difficulty sends a clear message to him that those
two modules should not know about each other and that he needs to
find another way to solve his problem. By controlling access to
instances, you control coupling.</p>
</li>
<li>
<p><strong>They aren't concurrency-friendly.</strong> The days of games running on
    a simple single-core CPU are pretty much over. Code today must
    at the very least <em>work</em> in a multi-threaded way even if it
    doesn't take full advantage of concurrency. When we make something
    global, we've created a chunk of memory that every thread can see
    and poke at, whether or not they know what other threads are doing
    to it. That path leads to deadlocks, race conditions, and other
    hell-to-fix thread-synchronization bugs.</p>
</li>
</ul>
<p>Issues like these are enough to scare us away from declaring a global
variable, and thus the Singleton pattern too, but that still doesn't
tell us how we <em>should</em> design the game. How do you architect a game
without global state?</p>
<p>There are some extensive answers to that question (most of this book
in many ways <em>is</em> an answer to just that), but they aren't apparent or
easy to come by. In the meantime, we have to get games out the door.
The Singleton pattern looks like a panacea. It's in a book on
object-oriented design patterns, so it <em>must</em> be architecturally
sound, right? And it lets us design software the way we have been
doing for years.</p>
<p>Unfortunately, it's more placebo than cure. If you scan the list of
problems that globals cause, you'll notice that the Singleton pattern
doesn't solve any of them. That's because a Singleton <em>is</em> global
state, just encapsulated in a class.</p>
<h3><a href="#it-solves-two-problems-even-when-you-just-have-one" name="it-solves-two-problems-even-when-you-just-have-one">It solves two problems even when you just have one</a></h3>
<p>The word &ldquo;and&rdquo; in the Gang of Four's description of
Singleton is a bit strange. Is this pattern a solution to one problem
or two? What if we have only one of those? Ensuring a single instance
is useful, but who says we want to let <em>everyone</em> poke at it?
Likewise, global access is convenient, but that's true even for a
class that allows multiple instances.</p>
<p>The latter of those two problems, convenient access, is almost always
why we turn to the Singleton pattern. Consider a logging class. Most
modules in the game can benefit from being able to log diagnostic
information. However, passing an instance of our <code>Log</code> class to every
single function clutters the method signature and distracts from the
intent of the code.</p>
<p>The obvious fix is to make our Log class a Singleton. Every function
can then go straight to the class itself to get an instance. But when
we do that, we inadvertently acquire a strange little restriction. All
of the sudden, we can no longer create more than one logger.</p>
<p>At first, this isn't a problem. We're writing only a single log file,
so we only need one instance anyway. Then, deep in the development
cycle, we run into trouble. Everyone on the team has been using the
logger for their own diagnostics, and the log file has become a
massive dumping ground. Programmers have to wade through pages of text
just to find the one entry they care about.</p>
<p>We'd like to fix this by partitioning the logging into multiple files.
To do this, we'll have separate loggers for different game <span name="worse">domains</span>:
online, UI, audio, gameplay. But we can't. Not only does our <code>Log</code>
class no longer allow us to create multiple instances, that design
limitation is entrenched in every single call site that uses it:</p>
<div class="codehilite"><pre><span class="n">Log</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Some event.&quot;</span><span class="p">);</span>
</pre></div>


<p>In order to make our Log class support multiple instantiation (like it
originally did), we'll have to fix both the class itself and every
single call site that uses it. Our convenient access isn't so
convenient anymore.</p>
<aside name="worse">

<p>It could be even worse than this. Imagine your <code>Log</code> class is in a
library being shared across several <em>games</em>. Now, to change the
design, you'll have to coordinate the change across several groups of
people, most of whom have neither the time nor the motivation to fix
it.</p>
</aside>

<h3><a href="#lazy-initialization-takes-control-away-from-you" name="lazy-initialization-takes-control-away-from-you">Lazy initialization takes control away from you</a></h3>
<p>In the desktop PC world of virtual memory and soft performance
requirements, lazy initialization is a smart trick. Games are a
different animal. Initializing a system can take time: allocating
memory, loading resources, etc. If initializing the audio system takes
a few hundred milliseconds, we need to control when that's going to
happen. If we let it lazy-initialize itself the first time a sound
plays, that could be in the middle of an action-packed part of the
game, causing visibly dropped frames and stuttering gameplay.</p>
<p>Likewise, games generally need to closely control how memory is laid
out in the heap to avoid memory <span name="fragment">fragmentation</span>. If our audio system
allocates a chunk of heap when it initializes, we want to know <em>when</em>
that initialization is going to happen, so that we can control <em>where</em>
in the heap that memory will live.</p>
<aside name="fragment">

<p>See <a class="pattern" href="object-pool.html">Object Pool</a> for a detailed
explanation of memory fragmentation.</p>
</aside>

<p>Because of these two problems, most games I've seen don't rely on lazy
initialization. Instead, they implement the Singleton pattern like
this:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">static</span> <span class="n">FileSystem</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instance_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">FileSystem</span><span class="p">()</span> <span class="p">{}</span>

  <span class="k">static</span> <span class="n">FileSystem</span> <span class="n">instance_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>That solves the lazy initialization problem, but at the expense of
discarding several Singleton features that <em>do</em> make it better than
a raw global variable. With a static instance, we can no longer use
polymorphism, and the class must be constructible at static
initialization time. Nor can we free the memory that the instance is
using when not needed.</p>
<p>Instead of creating a Singleton, what we really have here is a simple
static class. That isn't necessarily a bad thing, but if a static
class is all you need, <span name="static">why not</span> get rid of the <code>instance()</code> method
entirely and use static functions instead? Calling <code>Foo::bar()</code> is
simpler than <code>Foo::instance().bar()</code>, and also makes it clear that you
really are dealing with static memory.</p>
<aside name="static">

<p>The usual argument for choosing Singletons over static classes is
that if you decide to change the static class into a non-static one
later, you'll need to fix every call site. In theory, you don't have
to do that with Singletons, because you could be passing the instance
around and calling it like a normal instance method.</p>
<p>In practice, I don't think I've ever seen that happen. Everyone just
does <code>Foo::instance().bar()</code> in one line. So, if we changed Foo to not
be a Singleton, we'd still have to touch every call site. Given that,
I'd rather have a simpler class, and a simpler syntax to call into it.</p>
</aside>

<h2><a href="#what-we-can-do-instead" name="what-we-can-do-instead">What We Can Do Instead</a></h2>
<p>If I've accomplished my goal so far, you'll think twice before you
pull Singleton out of your toolbox the next time you have a problem.
But you still have a problem that needs solving. What tool <em>should</em>
you pull out? Depending on what you're trying to do, I have a few
options for you to consider, but first&hellip;</p>
<h3><a href="#see-if-you-need-the-class-at-all" name="see-if-you-need-the-class-at-all">See if you need the class at all</a></h3>
<p>Most of the Singleton classes I see in games are "managers": those
nebulous classes that exist just to babysit other objects. I've seen
codebases where it seems like <em>every</em> class has a manager: Monster,
MonsterManager, Particle, ParticleManager, Sound, SoundManager,
ManagerManager. Sometimes, for variety, they'll throw a "System" or
"Engine" in there, but it's still the same idea.</p>
<p>While caretaker classes are sometimes useful, often they just reflect
unfamiliarity with OOP. Consider these two contrived classes:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bullet</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">getX</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x_</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">getY</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">y_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">setX</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setY</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="n">y_</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BulletManager</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Bullet</span><span class="o">*</span> <span class="n">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Bullet</span><span class="o">*</span> <span class="n">bullet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bullet</span><span class="p">();</span>
    <span class="n">bullet</span><span class="o">-&gt;</span><span class="n">setX</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">bullet</span><span class="o">-&gt;</span><span class="n">setY</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">bullet</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isOnScreen</span><span class="p">(</span><span class="n">Bullet</span><span class="o">&amp;</span> <span class="n">bullet</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">bullet</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
           <span class="n">bullet</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">SCREEN_WIDTH</span> <span class="o">&amp;&amp;</span>
           <span class="n">bullet</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
           <span class="n">bullet</span><span class="p">.</span><span class="n">getY</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">SCREEN_HEIGHT</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="n">Bullet</span><span class="o">&amp;</span> <span class="n">bullet</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">bullet</span><span class="p">.</span><span class="n">setX</span><span class="p">(</span><span class="n">bullet</span><span class="p">.</span><span class="n">getX</span><span class="p">()</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>Maybe this example is a bit dumb, but I've seen plenty of code that
reveals a design just like this after you scrape away the crusty
details. If you look at this code, it's natural to think that
BulletManager should be a Singleton. After all, anything that has a
Bullet will need the manager too, and how many instances of
BulletManager do you need?</p>
<p>The answer here is <em>zero</em>, actually. Here's how we solve the
"singleton" problem for our manager class:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bullet</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Bullet</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y_</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">isOnScreen</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">x_</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x_</span> <span class="o">&lt;</span> <span class="n">SCREEN_WIDTH</span> <span class="o">&amp;&amp;</span>
           <span class="n">y_</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y_</span> <span class="o">&lt;</span> <span class="n">SCREEN_HEIGHT</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">move</span><span class="p">()</span> <span class="p">{</span> <span class="n">x_</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>There we go. No manager, no problem. Poorly-designed Singletons are
often "helpers" that add functionality to another class. If you can,
just move all of that behavior into the class it helps. After all, OOP is about letting objects take care of themselves.</p>
<p>Outside of managers, though, there are other problems where we'd
reach to Singleton for a solution. For each of those problems, there
are some alternative solutions to consider.</p>
<h3><a href="#to-limit-a-class-to-a-single-instance" name="to-limit-a-class-to-a-single-instance">To limit a class to a single instance</a></h3>
<p>This is one half of what the Singleton pattern gives you. As in our
file system example, it can be critical to ensure there's only a
single instance of a class.</p>
<p>However, that doesn't necessarily mean we also want to provide public
global access to that instance. We may want to restrict access to
certain areas of the code, or even make it entirely private to a
single class (For example, we may be wrapping our file system wrapper
inside another wrapper entirely.) In those cases, providing a public
global point of access weakens the architecture.</p>
<p>So we need a way to ensure single instantiation without providing
global access. There are a couple of ways to accomplish this. Here's
one:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">FileSystem</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">FileSystem</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">instantiated_</span><span class="p">);</span>
    <span class="n">instantiated_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">FileSystem</span><span class="p">()</span> <span class="p">{</span> <span class="n">instantiated_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">instantiated_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="n">FileSystem</span><span class="o">::</span><span class="n">instantiated_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>This class allows anyone to construct it, but will assert and fail if
you try to construct more than one instance. As long as the right code
creates the instance first, then we've ensured no other code can
either get at that instance or create their own. The class ensures the
single instantiation requirement it cares about, but doesn't dictate
how the class should be used.</p>
<p>The downside with this implementation is that the check to prevent
multiple instantiation is only done at <em>runtime</em>. The Singleton
pattern, in contrast, guarantees a single instance at compile time, by
the very nature of the class's structure.</p>
<h3><a href="#to-provide-convenient-access-to-an-instance" name="to-provide-convenient-access-to-an-instance">To provide convenient access to an instance</a></h3>
<p>Convenient access is the main reason we reach for Singletons&mdash;
they make it easy to get our hands on an object we need to use in a
lot of different places. That ease comes at a cost, though: it becomes
equally easy to get our hands on the object in places where we <em>don't</em>
want it being used.</p>
<p>The general rule is that we want variables to be as narrowly scoped as
possible while still getting the job done. The smaller the scope an
object has, the fewer places we need to keep in our head while we're
working with it. Before we take the shotgun approach of a Singleton
object with <em>global</em> scope, let's consider other ways our codebase can
get access to an object.</p>
<h4><a href="#pass-it-in" name="pass-it-in">Pass it in</a></h4>
<p>The simplest solution, and often the best, is to simply pass the
object you need as argument to the functions that need it. It's worth
considering before we discard it as too cumbersome.</p>
<p>Consider a function for rendering objects. In order to render, it
needs access to an object that represents the graphics device and maintains the render state. Passing in this object as an argument to
functions that need to render is a common solution, common enough to
be a pattern in this book: <a class="pattern" href="context-object.html">Context Parameter</a>.</p>
<p>On the other hand, some objects don't belong in the signature of a
method. For example, a function that handles AI may need to also write
to a <span name="aop">log file</span>, but logging isn't its core concern. It would be strange
to see <code>Log</code> show up in its argument list. For cross-cutting concerns
like logging, we'll want to consider other options.</p>
<aside name="aop">

<p>The term for things like logging that appear scattered throughout a codebase
is a "cross-cutting concern". Handling cross-cutting concerns gracefully is a continuing architectural challenge, especially in statically typed languages.</p>
<p>"Aspect-oriented programming" was designed to address just
these concerns.</p>
</aside>

<h4><a href="#get-it-from-the-base-class" name="get-it-from-the-base-class">Get it from the base class</a></h4>
<p>Many game architectures have shallow but wide inheritance hierarchies,
often only one level deep. For example, you may have a base
<code>GameObject</code> class, with derived classes for each enemy or object in
the game. With architectures like this, a large portion of the game
code will live in these "leaf" derived classes. This means that all
these classes already has access to the same thing: their <code>GameObject</code>
base class. We can use that to our advantage:</p>
<p><span name="gameobject"></span></p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">GameObject</span>
<span class="p">{</span>
<span class="nl">protected:</span>
  <span class="n">ILog</span><span class="o">&amp;</span> <span class="n">getLog</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">log_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="n">ILog</span><span class="o">&amp;</span> <span class="n">log_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Enemy</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameObject</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="n">doSomething</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">getLog</span><span class="p">().</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;I can log!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>With this, nothing outside of <code>GameObject</code> has access to its <code>Log</code>
object, but every derived entity does, using <code>getLog()</code>. This pattern
of letting derived objects implement themselves in terms of protected
methods provided to them is covered in the <a class="pattern"
href="subclass-sandbox.html">Subclass Sandbox</a> chapter.</p>
<aside name="gameobject">

<p>This raises the question, "how does <code>GameObject</code> get the log
instance?" A simple solution is to have the base class simply create
and own a static instance. If you don't want the base class to take
such an active role, another popular solution is to use dependency
injection.</p>
<p>With this, outside code gives <code>GameObject</code> the <code>Log</code> instance that it
will use. Among other nice things, it makes it easier to isolate
<code>GameObject</code> from other classes for testing purposes. The chapter on
the <a class="pattern" href="service-locator.html">Service Locator</a>
pattern goes into this in depth.</p>
</aside>

<h4><a href="#get-it-from-something-already-global" name="get-it-from-something-already-global">Get it from something already global</a></h4>
<p>The goal of removing <em>all</em> global state is admirable, but rarely
practical. Most codebases will still have a couple of globally
available objects, for example a single <code>Game</code> or <code>World</code> object
representing the entire game state.</p>
<p>You can use this to your advantage and reduce the number of global
classes by piggybacking on existing ones. Instead of making Singletons
out of <code>Log</code>, <code>FileSystem</code>, and <code>AudioPlayer</code>, do this:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">World</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">static</span> <span class="n">World</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instance_</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Functions to set log_, et. al. ...</span>

  <span class="n">Log</span><span class="o">&amp;</span>         <span class="n">getLog</span><span class="p">()</span>         <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">log_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">FileSystem</span><span class="o">&amp;</span>  <span class="n">getFileSystem</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">fileSystem_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">AudioPlayer</span><span class="o">&amp;</span> <span class="n">getAudioPlayer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">audioPlayer_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="n">World</span> <span class="n">instance_</span><span class="p">;</span>

  <span class="n">Log</span>         <span class="o">*</span><span class="n">log_</span><span class="p">;</span>
  <span class="n">FileSystem</span>  <span class="o">*</span><span class="n">fileSystem_</span><span class="p">;</span>
  <span class="n">AudioPlayer</span> <span class="o">*</span><span class="n">audioPlayer_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>With this, only <code>World</code> is globally-available. Functions can get to
the other systems <span name="demeter">through</span> it:</p>
<div class="codehilite"><pre><span class="n">World</span><span class="o">::</span><span class="n">instance</span><span class="p">().</span><span class="n">getAudioPlayer</span><span class="p">().</span><span class="n">play</span><span class="p">(</span><span class="n">VERY_LOUD_BANG</span><span class="p">);</span>
</pre></div>


<aside name="demeter">

<p>Purists will claim this violates the Law of Demeter. I claim that's
still better than a giant pile of Singletons.</p>
</aside>

<p>If, later, the architecture is changed to support multiple <code>World</code>
instances (perhaps for streaming or testing purposes), <code>Log</code>,
<code>FileSystem</code>, and <code>AudioPlayer</code> are all unaffected&mdash; they won't
even know the difference. The downside with this, of course, is that
more code ends up coupled to World itself. If a class just needs to
play sound, our example still requires it to know about World in order
to get to the audio player.</p>
<p>We solve this with a hybrid solution. Code that already knows about
World can simply access <code>AudioPlayer</code> directly from it. For code that
doesn't, we provide access to <code>AudioPlayer</code> using one of the other
options described here.</p>
<h4><a href="#get-it-from-a-service-locator" name="get-it-from-a-service-locator">Get it from a Service Locator</a></h4>
<p>So far, we're assuming the global class is some regular concrete class
like World. Another option is to define a class whose sole reason for
being is to give global access to objects. This common pattern is
called a <a class="pattern" href="service-locator.html">Service
Locator</a> and gets its own chapter.</p>
<h2><a href="#what's-left-for-singleton" name="what's-left-for-singleton">What's Left for Singleton</a></h2>
<p>The question remains, where <em>should</em> we use the real Singleton
pattern? Honestly, I've never used the full Gang of Four
implementation in a game. To ensure single instantiation, I usually
simply use a static class. If that doesn't work, I'll use a static
flag to check at runtime that only one instance of the class is
constructed.</p>
<p>To provide access to an object, there are several patterns in this
book that don't cause the headache that global access causes. In rough
order of frequency, I tend to use <a class="pattern"
href="subclass-sandbox.html">Subclass Sandboxes</a>, <a class="pattern"
href="context-object.html">Context Parameters</a>, and <a
class="pattern" href="service-locator.html">Service Locators</a>.</p>
<p class="footer">&copy; 2009-2013 Robert Nystrom &mdash; Last modified on July 25, 2013</p>
</div>
</body>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</html> <!-- mod_str -->
