<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Game Programming Patterns / Sequencing Patterns / Double Buffer</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
</head>
<body id="top">
<div class="nav">
  <div class="bar">
    <div class="column">
      <h1 class="thread">&larr; <a href="sequencing-patterns.html">Sequencing Patterns</a> | <a href="game-loop.html">Game Loop</a> &rarr;
      <h1>&equiv; <a href="index.html">Game Programming Patterns</a></h1>
    </div>
  </div>
  <div class="column">
    <table>
      <tr>
        <td width="30%" class="section-nav">
          <h2>Double Buffer</h2>
          <ul><li>
<a href="#intent">Intent</a></li><li>
<a href="#motivation">Motivation</a></li><li>
<a href="#the-pattern">The Pattern</a></li><li>
<a href="#when-to-use-it">When to Use It</a></li><li>
<a href="#keep-in-mind">Keep in Mind</a></li><li>
<a href="#sample-code">Sample Code</a></li><li>
<a href="#design-decisions">Design Decisions</a></li><li>
<a href="#see-also">See Also</a></li></ul>

        </td>
        <td width="70%">
          <h2>Chapters</h2>
<ul>
  <li><a href="introduction.html">Introduction</a>
    <ul>
      <li><a href="architecture-performance-and-games.html">Architecture, Performance, and Games</a></li>
    </ul>
  </li>
  <li><a href="design-patterns-revisited.html">Design Patterns Revisited</a>
    <ul>
      <li><a href="command.html">Command</a>,
        <a href="flyweight.html">Flyweight</a>,
        <a href="observer.html">Observer</a>,
        <a href="prototype.html">Prototype</a>,
        <a href="singleton.html">Singleton</a>,
        <a href="state.html">State</a></li>
    </ul>
  </li>
  <li><a href="sequencing-patterns.html">Sequencing Patterns</a>
    <ul>
      <li><a href="double-buffer.html">Double Buffer</a>,
        <a href="game-loop.html">Game Loop</a>,
        <a href="update-method.html">Update Method</a></li>
    </ul>
  </li>
  <li><a href="behavioral-patterns.html">Behavioral Patterns</a>
    <ul>
      <li><a href="bytecode.html">Bytecode</a>,
      <a href="subclass-sandbox.html">Subclass Sandbox</a>,
      <a href="type-object.html">Type Object</a></li>
    </ul>
  </li>
  <li><a href="decoupling-patterns.html">Decoupling Patterns</a>
    <ul>
      <li><a href="component.html">Component</a>,
        <a href="event-queue.html">Event Queue</a>,
        <a href="service-locator.html">Service Locator</a></li>
    </ul>
  </li>
  <li><a href="optimization-patterns.html">Optimization Patterns</a>
    <ul>
      <li><a href="data-locality.html">Data Locality</a>,
      <a href="dirty-flag.html">Dirty Flag</a>,
      <a href="object-pool.html">Object Pool</a>,
      <a href="spatial-partition.html">Spatial Partition</a></li>
    </ul>
  </li>
</ul>
        </td>
      </tr>
    </table>
  </div>
</div>
<div class="page sidebar">
<div class="content">
<h1>Double Buffer</h1>
<h1 class="book"><a href="index.html">Game Programming Patterns</a><span class="section"><a href="sequencing-patterns.html">Sequencing Patterns</a></span></h1>
<h2><a href="#intent" name="intent">Intent</a></h2>
<p><em>Cause a series of sequential operations to appear instantaneous or
simultaneous.</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<p>In their hearts, computers are <span name="sequential">sequential</span> beasts. Their power comes
from being able to break down the largest tasks into tiny steps that
can be performed one after another. Often, though, our users need to
see things occur in a single instanteous step, or see multiple tasks
performed simultaneously.</p>
<aside name="sequential">

<p>With threading and multi-core architectures, this is becoming less
true, but even with several cores only a few operations are really
running concurrently.</p>
</aside>

<p>A typical example, and one that every game engine must address, is
rendering. When the game draws the world the users see, it does so one
piece at a time: the mountains in the distance, the rolling hills, the
trees, each in its turn. If the user <em>watched</em> the view draw
incrementally like that, the illusion of a coherent world would be
shattered. The scene must update smoothly and quickly, displaying a
series of complete frames, each appearing instantly.</p>
<p>The Double Buffer pattern will let us solve this problem, but first
we&#x2019;ll need to take an aside to talk about how a computer displays
graphics.</p>
<h3><a href="#how-computer-graphics-work-(briefly)" name="how-computer-graphics-work-(briefly)">How computer graphics work (briefly)</a></h3>
<p>A <span name="scan">video</span> display like a computer monitor draws one pixel at a time. It
sweeps across each row of pixels from left to right, and then moves
down to the next row. When it reaches the bottom right corner, it
scans back up to the top left and starts all over again. It does this
so fast&thinsp;&mdash;&thinsp;around sixty times a second&thinsp;&mdash;&thinsp;that our eyes can&#x2019;t
see the scanning. To us, it&#x2019;s a single static field of colored pixels,
an image.</p>
<aside name="scan">

<p>This explanation is a bit of a simplification. If you&#x2019;re a low-level
hardware person and you&#x2019;re cringing right now, feel free to skip to
the next section. You already know enough to understand the rest of
the chapter. If you <em>aren&#x2019;t</em> that person, my goal here is to give you
just enough context to understand the pattern we&#x2019;ll discuss later.</p>
</aside>

<p>You can think of this process like a tiny hose that pipes pixels to
the display. Individual colors go into the back of the hose, and it
sprays them out across the display, one bit of color to each pixel in
its turn. So how does the hose know what colors go where?</p>
<p>In most computers, the answer is that it pulls them from a
<em>framebuffer</em>. A framebuffer is an array of pixels in memory, a chunk
of RAM where each couple of <span name="color">bytes</span> represents the color of a single
pixel. As the hose sprays across the display, it reads in the color
values from this array, one byte at a time.</p>
<aside name="color">

<p>The specific mapping between byte values and colors is described by
the <em>pixel format</em> and the <em>color depth</em> of the system. In most gaming
consoles today, each pixel gets 32 bits: eight each for the red, green
and blue channels, and another eight left over for various other
purposes.</p>
</aside>

<p>In order to get our game to appear on screen, all we ultimately do is
write to that array. All of the crazy advanced graphics algorithms we
have eventually boil down to just that: setting byte values in the
framebuffer. But there&#x2019;s a little problem:</p>
<p>Earlier, I said computers are sequential. If it&#x2019;s executing a chunk of
<em>our</em> rendering code, we don&#x2019;t expect it to be doing anything else at
the same time. That&#x2019;s mostly accurate, but a couple of things <em>do</em>
happen in the middle of our program running. One of those is that the
video display will be reading from the framebuffer <em>constantly</em> while
our game runs. This can cause a problem for us.</p>
<p>Let&#x2019;s say we want a big red circle to appear on screen. Our program
starts looping through the framebuffer, setting pixels to red. What we
don&#x2019;t realize is that the video driver is pulling from the framebuffer
right as we&#x2019;re writing to it. As it scans across the pixels we&#x2019;ve
written, our circle starts to appear. But then it outpaces us and
moves into pixels we haven&#x2019;t gotten to yet. The result is <em>tearing:</em> a
hideous visual bug where you see half of something drawn on screen.</p>
<p><span name="tearing"></span></p>
<p><img src="images/double-buffer-tearing.png" /></p>
<aside name="tearing">

<p>We start drawing pixels just as the video driver starts
reading from the framebuffer (Fig. 1). The video driver eventually
catches up to the renderer and then races past it to pixels we haven&#x2019;t
written yet (Fig. 2). We finish drawing (Fig. 3), but the driver
doesn&#x2019;t catch those new pixels.</p>
<p>The result (Fig. 4) is that the user sees half of the drawing. The name "tearing" comes from the fact that it looks like the bottom half was torn off.</p>
</aside>

<p>This is why we need this pattern. Our program renders the pixels one
at a time, but we need the display driver to see them all at
once&thinsp;&mdash;&thinsp;one refresh the circle isn&#x2019;t there, the next one it is.
Double buffering solves this. I&#x2019;ll explain how by analogy.</p>
<h3><a href="#act-1,-scene-1" name="act-1,-scene-1">Act 1, Scene 1</a></h3>
<p>Imagine our users are watching a play, produced by ourselves. As scene
one ends and scene two starts, we need to change the stage setting. If
we just have the stagehands run on after the scene and start dragging
props around, the illusion of a coherent place will be broken. We
could dim the lights while we do that (which of course, is what real
theaters do), but the audience still knows <em>something</em> is going on
then. We want there to be no gap in time between scenes.</p>
<p>So, with a bit of real estate we come up with this clever solution: We
build <span name="stage"><em>two</em></span> stages set up so the audience can see both. Each has its
own set of lights. We&#x2019;ll call them stage A and B. Scene one is shown
on stage A. Meanwhile, stage B is dark and the stagehands are setting
up scene two on it. As soon as scene one ends, we cut the lights on
stage A, and bring them up on stage B. The audience looks to the new
stage and scene two begins immediately.</p>
<p>At the same time, our stagehands are over on the now darkened stage
<em>A</em>, striking scene one and setting up scene <em>three</em>. As soon as scene
two ends, we switch the lights again back to stage A. We continue this
process for the entire play, using the darkened stage as a work area
where we can set up the next scene. Every scene transition, we just
toggle the lights between the two stages. Our audience gets a
continuous performance with no delay between scenes. They never see a
stagehand.</p>
<aside name="stage">

<p>Using a half-silvered mirror and some very smart layout, you could
actually build this so that the two stages appear to the audience in
the same <em>place</em>. As soon as the lights switch, they would be looking
at a different stage, but would never have to change where they look.
Building this is left as an exercise for the reader.</p>
</aside>

<h3><a href="#back-to-the-graphics" name="back-to-the-graphics">Back to the graphics</a></h3>
<p>That is <span name="sync">exactly</span> how double buffering works, and this process underlies
the rendering system of just about every game you&#x2019;ve ever seen.
Instead of a single framebuffer, we have <em>two</em>. One of them represents
the current frame. This one, stage A in our analogy, is the one the
video hardware is reading from. It can scan through it as much as it
wants whenever it wants.</p>
<aside name="sync">

<p>Not <em>all</em> games and consoles do this, though. Older and simpler
consoles where memory is limited actually carefully sync their
drawing to the video refresh instead. It&#x2019;s tricky.</p>
</aside>

<p>Meanwhile, our rendering code is writing to the <em>other</em> buffer. This
is our darkened stage B. When our rendering code is done drawing the
scene, it switches the lights by <em>swapping</em> the buffers. This tells
the video hardware to start reading from the second buffer now instead
of the first one. As long as it times that switch at the end of a
refresh, we won&#x2019;t get any tearing, and the entire scene will appear
all at once.</p>
<p>Meanwhile, the old framebuffer is now available for use. We start
rendering the next frame onto it. Voil&agrave;!</p>
<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<p>A <strong>buffered class</strong> encapsulates a <strong>buffer</strong>: a piece of state that
can be modified. This buffer is edited incrementally, but we want all
outside code to see the edit as a single atomic change. To do this,
the class keeps <em>two</em> instances of the buffer, a <strong>next buffer</strong> and a
<strong>current buffer</strong>.</p>
<p>When information is read <em>from</em> a buffer, it is always from the
<em>current</em> buffer. When information is <em>written</em> to a buffer, it occurs
on the <em>next</em> buffer. When the changes are complete, a <strong>swap</strong>
operation swaps the next and current buffers instantly so that the new
buffer is now publicly visible. The old current buffer is now
available to be reused as the new next buffer.</p>
<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<p>This pattern is one of those ones where you&#x2019;ll know when you need it.
If you have a system that lacks double buffering, it will probably
look visibly wrong (tearing, etc.) or will behave incorrectly. But saying, "you&#x2019;ll know when you need it" doesn&#x2019;t give you much to go
on. More specifically, this pattern is appropriate when these four
things are true:</p>
<ol>
<li>
<p>We have some state that is being modified incrementally.</p>
</li>
<li>
<p>That same state may be accessed in the middle of modification.</p>
</li>
<li>
<p>We want to prevent the code that&#x2019;s accessing the state from
    seeing the work-in-progress.</p>
</li>
<li>
<p>We want to be able to read the state and we don&#x2019;t want to have to
    wait while it&#x2019;s being written.</p>
</li>
</ol>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<p>Unlike larger architectural patterns, double buffering exists at a
lower implementation level. Because of this, it has fewer consequences
for the rest of the codebase&thinsp;&mdash;&thinsp;most of the game won&#x2019;t even be
aware of the difference. There are a couple of caveats, though.</p>
<h3><a href="#the-swap-itself-takes-time" name="the-swap-itself-takes-time">The swap itself takes time</a></h3>
<p>Double-buffering requires a <em>swap</em> step once the state is done being
modified. That operation must be atomic&thinsp;&mdash;&thinsp;no code can access
either state while they are being swapped. Often, the swap is as quick
as assigning a pointer, but if it takes longer than it does to modify
the state to begin with, then we haven&#x2019;t helped ourselves at all.</p>
<h3><a href="#we-have-to-have-two-buffers" name="we-have-to-have-two-buffers">We have to have two buffers</a></h3>
<p>The other consequence of this pattern is memory usage. As its
name implies, the pattern requires you to keep <em>two</em> copies of your
state in memory at all times. On memory-constrained consoles, this
can be a heavy price to pay. If you can&#x2019;t afford two buffers, you may
have to look into other ways to ensure your state isn&#x2019;t being accessed
during modification.</p>
<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<p>Now that we&#x2019;ve got the theory, let&#x2019;s see how it works in practice.
We&#x2019;ll write a very bare-bones graphics system that lets us draw pixels
on a frame buffer. In most consoles and PCs, this low-level part of
the graphics system is provided by the video driver, but this will let
us see what&#x2019;s going on. First up is the buffer itself:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Framebuffer</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Framebuffer</span><span class="p">()</span> <span class="p">{</span> <span class="n">clear</span><span class="p">();</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">WIDTH</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">pixels_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">WHITE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">pixels_</span><span class="p">[(</span><span class="n">WIDTH</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">getPixels</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">pixels_</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">160</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">120</span><span class="p">;</span>

  <span class="kt">char</span> <span class="n">pixels_</span><span class="p">[</span><span class="n">WIDTH</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>It has basic operations for clearing the entire buffer to a default
color, and setting the color of an individual pixel. It also has a
function, <code>getPixels()</code>, to expose the raw array of memory holding the
pixel data. We won&#x2019;t see this in the example, but the video driver
will be calling that function frequently to stream memory from the
buffer onto the screen.</p>
<p>We&#x2019;ll wrap this raw buffer in a <code>Scene</code> class. It&#x2019;s job here is to
render something by making a bunch of <code>draw()</code> calls on its buffer:</p>
<p><span name="draw"></span></p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Scene</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span><span class="o">&amp;</span> <span class="n">getBuffer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">buffer_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Framebuffer</span> <span class="n">buffer_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="draw">

<p>Specifically, it draws this artistic masterpiece:</p>
<p><img src="images/double-buffer-face.png" width="240" /></p>
</aside>

<p>Every frame, the game tells the scene to draw. The scene clears the
buffer and then draws a bunch of pixels, one at a time. It also
provides access to the internal buffer through <code>getBuffer()</code> so that
the video driver can get to it.</p>
<p>This seems pretty straightforward, but if we leave it like this, we&#x2019;ll
run into problems. The trouble is that the video driver can call
<code>getPixels()</code> on the buffer at <em>any</em> point in time, even here:</p>
<div class="codehilite"><pre><span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// &lt;- Video driver reads pixels here!</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">buffer_</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>


<p>When that happens, the user will see the eyes of the face, but the
mouth will disappear for a single frame. The next frame, it could
get interrupted at some other point. The end result is horribly
flickering graphics and angry users.</p>
<p>We&#x2019;ll fix this with double buffering:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Scene</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Scene</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">current_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffers_</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
    <span class="n">next_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buffers_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>

    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">swap</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span><span class="o">&amp;</span> <span class="n">getBuffer</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">current_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">void</span> <span class="n">swap</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Just switch the pointers.</span>
    <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">current_</span><span class="p">;</span>
    <span class="n">current_</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span>
    <span class="n">next_</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Framebuffer</span>  <span class="n">buffers_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">current_</span><span class="p">;</span>
  <span class="n">Framebuffer</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Now <code>Scene</code> has two buffers, stored in the <code>buffers_</code> array. We don&#x2019;t
directly reference them from the array. Instead, there are two
members, <code>next_</code> and <code>current_</code>, that point into that array. When we
draw, we draw onto the next buffer, referenced by <code>next_</code>. When the
video driver needs to get at the pixels, it always accesses the
<em>other</em> buffer through <code>current_</code>.</p>
<p>This way, the video driver never sees the buffer that we&#x2019;re working
on. The only remaining piece of the puzzle is the call to <code>swap()</code>
when the scene is done drawing the frame. That swaps the two buffers
by simply switching the <code>next_</code> and <code>current_</code> references. The next
time the video driver calls <code>getBuffer()</code> it will now get the new
buffer we just finished drawing and put our recently drawing buffer
onscreen. No more tearing or unsightly glitches.</p>
<h3><a href="#not-just-for-graphics" name="not-just-for-graphics">Not just for graphics</a></h3>
<p>The core problem that a Double Buffer solves is state being accessed
while it&#x2019;s being modified. There are two common causes of this. We&#x2019;ve
covered the first one with our graphics example: the state is directly
accessed from code on another thread or interrupt.</p>
<p>There is another equally common cause, though: when the code <em>doing
the modification</em> is accessing the same state that it&#x2019;s modifying.
This can manifest in a variety of places, especially physics and AI
where you have entities interacting with each other. Double-buffering
is often necessary here too.</p>
<h3><a href="#artificial-unintelligence" name="artificial-unintelligence">Artificial unintelligence</a></h3>
<p>Let&#x2019;s say we&#x2019;re building the behavioral system for, of all things, a
game based on slapstick comedy. The game has a stage containing a
bunch of actors that run around and get up to various hijinks and
shenanigans. Here&#x2019;s our base actor:</p>
<p><span name="update"></span></p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Actor</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Actor</span><span class="p">()</span> <span class="o">:</span> <span class="n">slapped_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Actor</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span>      <span class="p">{</span> <span class="n">slapped_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">slap</span><span class="p">()</span>       <span class="p">{</span> <span class="n">slapped_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">wasSlapped</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">slapped_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">bool</span> <span class="n">slapped_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="update">

<p>This is an example of the <a class="pattern" href="update-method.html">Update Method</a>
pattern.</p>
</aside>

<p>Every frame, the game is responsible for calling <code>update()</code> on it so
that it has a chance to do some processing. Critically, from the
user&#x2019;s perspective, <em>all actors should appear to update
simultaneously</em>.</p>
<p>Actors can also interact with each other, if by "interacting", we mean
"they can slap each other around." When updating, the actor can call
<code>slap()</code> on another actor to slap it, and call <code>wasSlapped()</code> to determine if
it has been slapped.</p>
<p>The actors need a stage where they can interact, so let&#x2019;s build that:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Stage</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="n">Actor</span><span class="o">*</span> <span class="n">actor</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span> <span class="n">actors_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">actor</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ACTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
      <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_ACTORS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="n">Actor</span><span class="o">*</span> <span class="n">actors_</span><span class="p">[</span><span class="n">NUM_ACTORS</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>It lets us add actors, and provides a single <code>update()</code> call that will
update each actor. Even though actors will appear to move
simultaneously to the user, here they are updated one at a time.</p>
<p>The only other point to note is that each actor&#x2019;s "slapped" state is
cleared immediately after updating. This is so that an actor only
responds to a given slap once.</p>
<p>Now, to get things going, let&#x2019;s define a concrete actor subclass. Our
comedian here is pretty simple. He faces a single actor. Whenever he
gets slapped&thinsp;&mdash;&thinsp;by anyone&thinsp;&mdash;&thinsp;he responds by slapping the
actor he faces.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Comedian</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Actor</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">face</span><span class="p">(</span><span class="n">Actor</span><span class="o">*</span> <span class="n">actor</span><span class="p">)</span> <span class="p">{</span> <span class="n">facing_</span> <span class="o">=</span> <span class="n">actor</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">wasSlapped</span><span class="p">())</span> <span class="n">facing_</span><span class="o">-&gt;</span><span class="n">slap</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Actor</span><span class="o">*</span> <span class="n">facing_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Now lets throw some comedians on a stage and see what happens. We&#x2019;ll
set up three comedians, each facing the next. The last one will face
the first, in a big circle:</p>
<div class="codehilite"><pre><span class="n">Stage</span> <span class="n">stage</span><span class="p">;</span>

<span class="n">Comedian</span><span class="o">*</span> <span class="n">harry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comedian</span><span class="p">();</span>
<span class="n">Comedian</span><span class="o">*</span> <span class="n">baldy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comedian</span><span class="p">();</span>
<span class="n">Comedian</span><span class="o">*</span> <span class="n">chump</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Comedian</span><span class="p">();</span>

<span class="n">harry</span><span class="o">-&gt;</span><span class="n">face</span><span class="p">(</span><span class="n">baldy</span><span class="p">);</span>
<span class="n">baldy</span><span class="o">-&gt;</span><span class="n">face</span><span class="p">(</span><span class="n">chump</span><span class="p">);</span>
<span class="n">chump</span><span class="o">-&gt;</span><span class="n">face</span><span class="p">(</span><span class="n">harry</span><span class="p">);</span>

<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">harry</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">baldy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">chump</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>


<p>The resulting stage is set up a bit like the following image shows.
The arrows show who is facing who, and the numbers show their index
in the stage&#x2019;s array:</p>
<p><img src="images/double-buffer-slaps-1.png" /></p>
<p>Now, let&#x2019;s slap Harry to get things going and see what happens when
we start processing:</p>
<div class="codehilite"><pre><span class="n">harry</span><span class="o">-&gt;</span><span class="n">slap</span><span class="p">();</span>

<span class="n">stage</span><span class="p">.</span><span class="n">update</span><span class="p">();</span>
</pre></div>


<p>Remember that the <code>update()</code> function in Stage updates each actor in
turn, so if we step through the code, we&#x2019;ll find that the following
occurs:</p>
<div class="codehilite"><pre><span class="n">Stage</span> <span class="n">updates</span> <span class="n">actor</span> <span class="mi">0</span> <span class="p">(</span><span class="n">Harry</span><span class="p">)</span>
  <span class="n">Harry</span> <span class="n">was</span> <span class="n">slapped</span><span class="p">,</span> <span class="n">so</span> <span class="n">he</span> <span class="n">slaps</span> <span class="n">Baldy</span>
<span class="n">Stage</span> <span class="n">updates</span> <span class="n">actor</span> <span class="mi">1</span> <span class="p">(</span><span class="n">Baldy</span><span class="p">)</span>
  <span class="n">Baldy</span> <span class="n">was</span> <span class="n">slapped</span><span class="p">,</span> <span class="n">so</span> <span class="n">he</span> <span class="n">slaps</span> <span class="n">Chump</span>
<span class="n">Stage</span> <span class="n">updates</span> <span class="n">actor</span> <span class="mi">2</span> <span class="p">(</span><span class="n">Chump</span><span class="p">)</span>
  <span class="n">Chump</span> <span class="n">was</span> <span class="n">slapped</span><span class="p">,</span> <span class="n">so</span> <span class="n">he</span> <span class="n">slaps</span> <span class="n">Harry</span>
<span class="n">Stage</span> <span class="n">update</span> <span class="n">ends</span>
</pre></div>


<p>So, in a single frame, our initial slap on Harry has propogated
through all of the comedians. Now let&#x2019;s mix things up a bit. Lets say
we reorder the comedians within the stages array, but leaving them
still facing each other the same way.</p>
<p><img src="images/double-buffer-slaps-2.png" /></p>
<p>We&#x2019;ll leave the rest of the stage setup alone, but replace the chunk
of code where we add the actors to the stage with this:</p>
<div class="codehilite"><pre><span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">harry</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">baldy</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">stage</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">chump</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>


<p>We&#x2019;ll run our experiment again and let&#x2019;s see what happens:</p>
<div class="codehilite"><pre><span class="n">Stage</span> <span class="n">updates</span> <span class="n">actor</span> <span class="mi">0</span> <span class="p">(</span><span class="n">Chump</span><span class="p">)</span>
  <span class="n">Chump</span> <span class="n">was</span> <span class="n">not</span> <span class="n">slapped</span><span class="p">,</span> <span class="n">so</span> <span class="n">he</span> <span class="n">does</span> <span class="n">nothing</span>
<span class="n">Stage</span> <span class="n">updates</span> <span class="n">actor</span> <span class="mi">1</span> <span class="p">(</span><span class="n">Baldy</span><span class="p">)</span>
  <span class="n">Baldy</span> <span class="n">was</span> <span class="n">not</span> <span class="n">slapped</span><span class="p">,</span> <span class="n">so</span> <span class="n">he</span> <span class="n">does</span> <span class="n">nothing</span>
<span class="n">Stage</span> <span class="n">updates</span> <span class="n">actor</span> <span class="mi">2</span> <span class="p">(</span><span class="n">Harry</span><span class="p">)</span>
  <span class="n">Harry</span> <span class="n">was</span> <span class="n">slapped</span><span class="p">,</span> <span class="n">so</span> <span class="n">he</span> <span class="n">slaps</span> <span class="n">Baldy</span>
<span class="n">Stage</span> <span class="n">update</span> <span class="n">ends</span>
</pre></div>


<p>Uh, oh. Totally different. The problem is straightforward. When we
update the actors, we modify their "slapped" states, the exact same
state we also <em>read</em> during the update. Because of this, changes to
that state early in the update affect <span name="cascade">later</span> parts of that <em>same</em>
update step.</p>
<aside name="cascade">

<p>If you continue to update the stage, you&#x2019;ll see the slaps gradually
cascade through the actors, one per frame. In the first frame, Harry
slaps Baldy. In the next frame, Baldy slaps Chump, and so on.</p>
</aside>

<p>The ultimate result is that an actor may respond to being slapped on
either the <em>same</em> frame as the slap or the <em>next</em> frame, based
entirely on how the two actors happen to be ordered on the stage. This
violates our requirement that actors need to appear to run in
parallel: the order that they update within a single frame shouldn&#x2019;t
matter.</p>
<h3><a href="#buffered-slaps" name="buffered-slaps">Buffered slaps</a></h3>
<p>Fortunately, our Double Buffer pattern can help. This time, instead of
having two copies of a monolithic "buffer" object, we&#x2019;ll be buffering
at a much finer granularity: each actor&#x2019;s "slapped" state:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Actor</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Actor</span><span class="p">()</span> <span class="o">:</span> <span class="n">currentSlapped_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="o">~</span><span class="n">Actor</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">swap</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// Swap the buffer.</span>
    <span class="n">currentSlapped_</span> <span class="o">=</span> <span class="n">nextSlapped_</span><span class="p">;</span>

    <span class="c1">// Clear the new &quot;next&quot; buffer.</span>
    <span class="n">nextSlapped_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">slap</span><span class="p">()</span>       <span class="p">{</span> <span class="n">nextSlapped_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">wasSlapped</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">currentSlapped_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">bool</span> <span class="n">currentSlapped_</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">nextSlapped_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Instead of a single <code>slapped_</code> state, each actor now has two. Just
like the previous graphics example, the current state is used for
reading, and the next state is used for writing.</p>
<p>The <code>reset()</code> function has been replaced with <code>swap()</code>. Now, right
before clearing the swap state, it copies the next state into the
current one, making it the new current state. This also requires a
small change in <code>Stage</code>:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Stage</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ACTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_ACTORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">actors_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">swap</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Previous Stage code...</span>
<span class="p">};</span>
</pre></div>


<p>The <code>update()</code> function now updates all of the actors and <em>then</em> swaps
all of their states.</p>
<p>The end result of this is that an actor will only see a slap on the
frame <em>after</em> it was actually slapped. This way, no matter what order
they appear in the stage&#x2019;s array, they will behave the same. Updating
the actors happens simultaneously as far as the user or any outside
code can tell.</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<p>The Double Buffer pattern is pretty straightforward, and the examples
we&#x2019;ve seen so far cover most of the variations you&#x2019;re likely to
encounter. There are two main decisions that come up when implementing
it.</p>
<h3><a href="#how-are-the-buffers-swapped" name="how-are-the-buffers-swapped">How are the buffers swapped?</a></h3>
<p>The swap operation is the most critical step of the process since we
must lock out all reading and modification of both buffers while it&#x2019;s
occurring. To get the best performance, we want this to happen as
quickly as possible.</p>
<ul>
<li>
<p><strong>Swap pointers or references to the buffer:</strong></p>
<p>This is how our graphics example works, and is the most common
solution for double-buffering graphics.</p>
<ul>
<li>
<p><em>It&#x2019;s fast.</em> Regardless of how big the buffer is, the swap is
    simply a couple of pointer assignments. It&#x2019;s hard to beat that
    for speed and simplicity.</p>
</li>
<li>
<p><em>Prevents outside code from storing persistent pointer to
    buffer.</em> This is the main limitation. Since we don&#x2019;t actually
    move the <em>data</em>, what we&#x2019;re essentially doing is periodically
    telling the rest of the codebase to look somewhere else for
    the buffer, like in our original stage analogy. This means
    that the rest of the codebase can&#x2019;t store pointers directly
    to data within the buffer: they may be pointing at the wrong
    one a moment later.</p>
<p>This can be particularly troublesome on a system where the
video driver expects the framebuffer to always be at a fixed
location in memory. In that case, we won&#x2019;t be able to use
this option.</p>
</li>
<li>
<p><em>Existing data on the buffer will be from two frames ago, not
    the last frame.</em> Successive frames are drawn on alternating
    buffers, with no data copied between them, like so:</p>
<div class="codehilite"><pre>Frame 1 drawn on buffer A
Frame 2 drawn on buffer B
Frame 3 drawn on buffer A
...
</pre></div>


<p>You&#x2019;ll note that when we go to draw the third frame, the data
already on the buffer is from frame <em>one</em>, not the more
recent second frame. In most cases, this isn&#x2019;t an issue&thinsp;&mdash;&thinsp;we
usually just clear the whole buffer right before drawing.
But, if we intend to <span name="blur">reuse</span> some of the existing data on the
buffer, it&#x2019;s important to take into account that that data
will be a frame older than we might expect.</p>
<aside name="blur">

<p>One classic use of old framebuffer data is simulating motion blur. The
current frame is blended with a bit of the previously rendered frame,
to make a resulting image that looks more like what a real camera
captures.</p>
</aside>

</li>
</ul>
</li>
<li>
<p><strong>Copy the data between the buffers.</strong></p>
<p>If we can&#x2019;t just repoint users to the other buffer, the only other
option is to actually copy the data from the next frame to the
current frame. This is how our slapstick comedians work. In that
case, we chose this way because the state&thinsp;&mdash;&thinsp;a single boolean
flag&thinsp;&mdash;&thinsp;doesn&#x2019;t take any longer to copy than a pointer to the
buffer would.</p>
<ul>
<li>
<p><em>Data on the next buffer is only a single frame old.</em> This is
    the nice thing about copying the data as opposed to
    ping-ponging back and forth between the two buffers. If we
    need access to previous buffer data, this will give us more
    up-to-date data to work with.</p>
</li>
<li>
<p><em>Swapping can take more time.</em> This, of course, is the big
    negative point. Our swap operation now means copying the
    entire buffer in memory. If the buffer is large, like an
    entire framebuffer, it can a signficant chunk of time to do
    this. Since nothing can read or write to <em>either</em> buffer
    while this is happening, that&#x2019;s a big limitation.</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#what-is-the-granularity-of-the-buffer" name="what-is-the-granularity-of-the-buffer">What is the granularity of the buffer?</a></h3>
<p>The other question is how the buffer itself is organized: as a single
monolithic chunk of data, or distributed among a collection of
objects. Our graphics example uses the former, and the actors use the
latter.</p>
<p>Most of the time, the nature of what you&#x2019;re buffering will
lead to the answer, but there&#x2019;s some flexibility. For example, our
actors could have all stored their messages in a single message block
that they all reference into by their index.</p>
<ul>
<li>
<p><strong>If the buffer is monolithic:</strong></p>
<ul>
<li><p><em>Swapping is simpler.</em> Since there is only one pair of
    buffers, a single swap does it. If you can swap by changing
    pointers, then you can swap the entire buffer, regardless of
    size, with just a couple of assignments.</p></li>
</ul>
</li>
<li>
<p><strong>If many objects have a piece of data:</strong></p>
<ul>
<li>
<p><em>Swapping is slower.</em> In order to swap, we need to iterate
    through the entire collection of objects, telling each one
    to swap.</p>
<p>In our comedian example, that was OK since we needed to clear
the next slap state anyway&thinsp;&mdash;&thinsp;every piece of buffered
state needed to be touched each frame. If we don&#x2019;t need to
otherwise touch the old buffer, there&#x2019;s a simple optimization
we can do to get the same performance of a monolithic buffer
while distributing the buffer across multiple objects.</p>
<p>The idea is to get the "current" and "next" pointer concept
and apply it to each of our objects by turning them into
object-relative <em>offsets</em>. Like so:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Actor</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> <span class="n">current_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">()</span> <span class="p">{</span> <span class="n">current_</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span> <span class="p">}</span>

<span class="nl">protected:</span>
  <span class="kt">void</span> <span class="n">slap</span><span class="p">()</span>        <span class="p">{</span> <span class="n">slapped_</span><span class="p">[</span><span class="n">next</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">wasSlapped</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">slapped_</span><span class="p">[</span><span class="n">current_</span><span class="p">];</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">current_</span><span class="p">;</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="nf">next</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">current_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">slapped_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>Actors access their current slap state by using <code>current_</code> to
index into the state array. The next state is always the other
index in the array, so we can calculate that with <code>next()</code>.
Swapping the state just alternates the <code>current_</code> index.
The clever bit is that <code>swap()</code> is now a <em>static</em> function:
it only needs to be called once, and <em>every</em> actor&#x2019;s state
will be swapped.</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<ul>
<li><p>You can find this pattern in use in almost every graphics API
    out there. OpenGL has <code>swapBuffers()</code>. Microsoft&#x2019;s XNA framework
    swaps the framebuffers within its <code>endDraw()</code> function.</p></li>
</ul>
<p class="footer">&copy; 2009-2014 Robert Nystrom</p>
</div>
</div>
</body>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</html>
