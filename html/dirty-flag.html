<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Game Programming Patterns / Optimizing Patterns / Dirty Flag</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
</head>
<body id="top">
<div class="content">
<h1 class="book"><a href="index.html">Game Programming Patterns</a> / Optimizing Patterns</h1>
<h1>Dirty Flag</h1>
<div class="in-progress">
  <span class="dismiss">&times;</span>
  <p><strong>This book is a work in progress!</strong></p>

  <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/game-programming-patterns/issues/new" target="_blank">file a ticket</a>. To know when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="http://gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=0c27329244" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <table>
      <tr>
        <td width="100%">
          <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
        </td>
        <td>
          <div class="spacer"></div>
        </td>
        <td>
          <input type="submit" value="Join" name="subscribe" id="mc-embedded-subscribe" class="button">
        </td>
      </tr>
    </table>
  </form>
  </div>
  <!--End mc_embed_signup-->

  <table width="100%">
    <tr>
      <td width="50%">
        <p>Thank you!</p>
      </td>
      <td width="50%">
        <p class="signature">&mdash; Bob (<a href="https://twitter.com/intent/user?screen_name=munificentbob" target="_blank">@munificentbob</a>)</p>
      </td>
    </tr>
  </table>
</div>
<h2><a href="#intent" name="intent">Intent</a></h2>
<p><em>Avoid unneeded work by deferring it until the result is needed.</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<p><strong>TODO: renamed chapter, update this:</strong></p>
<p>OK, let&#x2019;s get two things out of the way first:</p>
<ol>
<li>
<p>Yes, the name of this chapter does make me giggle every time. I have the
    sense of humor of a ten-year-old boy.</p>
</li>
<li>
<p>This is actually the widely-used name of this pattern.
    <span name="google">Google it yourself.</span> Apparently I&#x2019;m not alone in
    my juvenile disposition. Another name for the same pattern is
    "dirty flag", but they are about equally commonly used. The Wikipedia
    article is <a href="http://en.wikipedia.org/wiki/Dirty_bit">"dirty bit"</a> (though
    it&#x2019;s about a more specific use of the term).</p>
</li>
</ol>
<aside name="google">

<p>You might want to wait until you&#x2019;re home from work before Googling it.</p>
</aside>

<p><strong>TODO: A better example would be recalculating matrices in a scene graph.</strong></p>
<p>Back to the matter at hand, let&#x2019;s talk about city-building games. I spent an
inordinate amount of my childhood in slavish devotion to Will Wright&#x2019;s masterpieces, so for this chapter, let&#x2019;s imagine we&#x2019;re making an homage to the classic mayoral role-playing game.</p>
<p>The player can build his city however he desires. As the city grows and develops, he occassionally is granted trophies and other rewards by his loving citizens. The player can bring up a trophy screen whenever he wants to bask in the light of his accomplishments. Here&#x2019;s where things get just a little bit tricky.</p>
<p>Every time the player gets a new trophy, the entire trophy case needs to be rearranged from scratch to generate a <span name="packing">maximally pleasing</span> arrangement. (You can imagine the virtual mayor spending hours lovingly doing this himself when he should be proofreading zoning agreements.) For our only-slightly-contrived example, let&#x2019;s pretend that that calculation is actually pretty time-consuming.</p>
<aside name="packing">

<p>Arranging the trophies is kind of like the <a href="http://en.wikipedia.org/wiki/Bin_packing">classic bin-packing problem</a>, which is NP-hard, so this being time-consuming isn&#x2019;t totally outside the bounds of reason.</p>
</aside>

<p>We could calculate the trophy arrangement every time the mayor gets a new trophy. That makes sure the trophy case is always up-to-date when they go to look at it. But, in practice, the player rarely goes to that screen. If they get <em>two</em> trophies between going to that screen, then we&#x2019;ll spend time generating the first arrangement, only to discard it without the player ever seeing it when the next trophy is awarded.</p>
<p>Instead, we could calculate the arrangement every time they enter the trophy room. But doing that is redundant if they go to the trophy room multiple times without having earned any new trophies. We&#x2019;ll just calculate the same arrangement each time.</p>
<p>The obvious solution is:</p>
<ol>
<li>
<p>When the mayor gets a new trophy, we set a special "need trophy arrangement" flag.</p>
</li>
<li>
<p>When the player enters the trophy room, we check that flag. If it&#x2019;s set, we calculate the trophy arrangement and clear it. Otherwise, we use the previously calculated arrangement, which is still up to date.</p>
</li>
</ol>
<p>The "need trophy arrangement" flag is the <em>dirty bit</em>. It&#x2019;s a single bit of data that indicates whether the current trophy arrangement is "dirty", or out of sync with the mayor&#x2019;s current set of trophies.</p>
<p>This is one of the two <span name="graphics">main uses</span> for this pattern in a nutshell. We&#x2019;ll cover the other related use a little farther down the chapter.</p>
<aside name="graphics">

<p>Back in the day when I was just a little game dev, this pattern used to have one particularly common application: rendering. Before GPUs, when games did all of their rendering in software, sprite engines were optimized to only redraw portions of the screen that actually changed.</p>
<p>The would maintain <em>dirty regions</em> that tracked which portions of the play area had been modified and needed re-rendering. These days with hardware-accelerated graphics, that technique is rarely needed anymore.</p>
</aside>

<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<p>A set of <strong>primary data changes</strong> over time. A set of <strong>derived data</strong> is determined from this using some <strong>complex calculation or synchronization</strong>. A <strong>"dirty" flag</strong> tracks when the derived data is out of sync with the primary data. It is <strong>set when the primary data changes</strong>. When the derived data is requested <strong>it is calculated only when the flag is set and the flag is cleared.</strong> Otherwise, the previous <strong>cached derived data</strong> is used.</p>
<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<p>Compared to some other patterns in this book, this one solves a pretty specific problem. Also, like most optimization patterns, you should only reach for it when you have a performance problem big enough to justify the added code complexity. Added up, this means you probably won&#x2019;t use this often.</p>
<p>Dirty bits are used to solve two related problems: <em>calculation</em> and <em>synchronization</em>. What they have in common is:</p>
<ol>
<li>A set of data that changes over time.</li>
<li>Another set of data that&#x2019;s somehow derived from that.</li>
<li>The process of going from 1 to 2 is "heavyweight".</li>
</ol>
<p>When you use this pattern for calculation, like in the example in the motivation section, it&#x2019;s because there is actual complex computation involved that you want to avoid. With synchronization, it&#x2019;s more often that the derived data is <em>somewhere else</em>&thinsp;&mdash;&thinsp;either on disk or over the network on another machine&thinsp;&mdash;&thinsp;and simply getting it from point A to point B is slow.</p>
<p>In either case, it turns out that doing that heavyweight work is often for naught. Every time the primary data changes, you have to ditch the previous derived data and generate it again to take into account the new stuff. If the primary data changes <em>again</em> before you ever actually use the data derived from it, then there&#x2019;s no point in doing that work.</p>
<p>That brings in a third requirement for this pattern: <em>the primary data has to change more often than the derived data is used</em>. If you always need the derived data every single time the primary data is modified, there&#x2019;s no way to avoid doing the work to generate it, and this pattern can&#x2019;t help you.</p>
<p>There&#x2019;s one final softer fourth requirement. It&#x2019;s implied here that you can&#x2019;t easily <em>incrementally</em> update the derived data when the primary data changes. This pattern comes into play with the derived data is only calculated from <em>the primary data</em> and not from <em>the previous derived data</em>.</p>
<p>For example, if the mayor&#x2019;s trophy room just lined the trophies up one after the other in the order they were awarded, this pattern wouldn&#x2019;t be helpful. Each time he got a trophy, we can calculate the position <em>of just that trophy</em> and then add it to the end of the row. Doing this would require using the previous derived data (the other trophy positions) and that means we&#x2019;d be best off updating the trophy positions <em>each time he gets a new trophy</em>.</p>
<p>In constrast, this pattern comes into play when the old derived data is totally discarded and calculated from scratch based on the primary data. In that case, we can <em>skip</em> updates without things getting out of sync since the previous derived data isn&#x2019;t used anyway.</p>
<p>All of this makes it sound like this pattern would never actually be useful, but over time you&#x2019;ll likely find a place here or there where it&#x2019;s a good fit. Grepping your average game codebase for the word "dirty" will often turn something up, and it almost always refers to this pattern.</p>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<p>Once you have convinced yourself this pattern is a good fit, there are a few wrinkled that can cause you some discomfort.</p>
<h3><a href="#deferring-until-the-result-is-needed-can-cause-a-noticeable-pause" name="deferring-until-the-result-is-needed-can-cause-a-noticeable-pause">Deferring until the result is needed can cause a noticeable pause</a></h3>
<p>In its simplest form, this pattern <aside name="gc">defers</aside> some slow work until the result is actually needed. But when the result is needed, it&#x2019;s often needed <em>right now</em> and the reason we&#x2019;re using this pattern to begin with is because calculating that result is slow!</p>
<p>In our example, if we wait until the player enters the trophy room to calculate the trophy positions, there may be a visible delay before the screen appears while the game is busy playing interior decorator. Sometimes, the pause is small enough that this isn&#x2019;t a problem.</p>
<p>When it is a problem, you&#x2019;ll often refine this pattern. There&#x2019;s actually a continuum of when to do the work ranging from "the second the primary data changes" all the way to "only at the last second when the derived data is needed". In between those two points are a range of options where you defer the work <em>somewhat</em> but still eventually kick it off before the result is actually needed.</p>
<p>When your fancy text editor auto-saves a backup "in the background" every few minutes, that&#x2019;s basically the trade-off it&#x2019;s making. The frequency that it auto-saves&thinsp;&mdash;&thinsp;every few minutes to once an hour&thinsp;&mdash;&thinsp;is picking a point on the continuum that balances not losing too much work when a crash occurs against not thrashing the file system too much by saving all the time.</p>
<p><span name="gc"></p>
<p>This is mirrors the different garbage collection strategies in systems that automatically manage memory. Reference counting systems free memory the second its no longer needed, but suffer by spending CPU time updating ref counts eagerly every time references are changed.</p>
<p>Simple garbage collectors defer reclaiming memory until it&#x2019;s really needed. But the cost here is the dreaded "GC pause" that can freeze your entire app until the GC is done walking the heap.</p>
<p>In between the two are increasingly common more complex systems like deferred ref-counting and incremental GC that reclaim memory less eagerly than pure ref-counting but more eagerly than stop-the-world collectors.</p>
<p></span></p>
<h3><a href="#you-have-to-make-sure-to-set-the-flag-*every*-time-the-state-changes" name="you-have-to-make-sure-to-set-the-flag-*every*-time-the-state-changes">You have to make sure to set the flag <em>every</em> time the state changes</a></h3>
<p>Since the derived data is calculated from the primary data, it&#x2019;s essentially a cache. Whenever you have cached data in memory, the trickiest aspect of it is <span name="cache"><em>cache invalidation</em></span>: correctly knowing when the cache is out of sync with its source data. In this pattern, that means correctly setting the dirty bit when <em>any</em> primary data changes.</p>
<aside name="cache">

<p>Phil Karlton famously said, "There are only two hard things in Computer Science: cache invalidation and naming things."</p>
<p>My favorite variation is, "There are only two hard things in Computer Science: cache invalidation, naming things, and off-by-one errors."</p>
</aside>

<p>Miss it in one place, and your program will incorrectly use stale derived data. This leads to confused players and very hard to track down bugs. When you use this pattern, you&#x2019;ll have to be very careful that any code that modifies the primary state also sets the dirty bit.</p>
<p>One way to mitigate this is by encapsulating modifications to the primary data behind some interface. If anything that can change the state goes a single simple interface, you can set the dirty bit there and rest assurred that it won&#x2019;t go out of sync.</p>
<h3><a href="#you-will-have-to-keep-the-previous-derived-data-in-memory" name="you-will-have-to-keep-the-previous-derived-data-in-memory">You will have to keep the previous derived data in memory</a></h3>
<p>When the game needs the derived data, it checks to see if the dirty flag is set. If it <em>isn&#x2019;t</em> set, then it uses the previously calculated data. This is obvious, but that does imply that you have to keep that derived data around in memory in case you end up needing it later.</p>
<p>If you weren&#x2019;t using this pattern, another option would be just calculate the derived data on the fly right when you need it, and then discard it when you&#x2019;re done. That avoids the expense of keeping it cached in memory. The cost doing this is calculation: you&#x2019;ll have to do that calculation <em>every</em> time you need it.</p>
<p>Like many optimizations, then, you can look at this pattern as trading off memory for space. In return for keeping the previously calculated data in memory, you avoid having to recalculate it when it&#x2019;s imput data hasn&#x2019;t changed. This trade-off makes sense when the calculation is slow and memory is cheap. When you&#x2019;ve got more time than memory on your hands, it may be better to just calculate it as needed and avoid this pattern.</p>
<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<p>Assuming we&#x2019;ve met the surprisingly long list of requirements and this pattern does make sense for out problem, let&#x2019;s see how it looks to code it up. The initial problem in the motivation section is pretty obvious to implement. Whenever the mayor gets a new trophy, we set the flag. When the player opens the trophy screen, we check the flag. If it&#x2019;s set, we layout the trophies, clear the flag and continue.</p>
<p>I&#x2019;m pretty sure you can code that up on your own, so let&#x2019;s leave that as an exercise for the reader. Instead, let&#x2019;s do a different example showing the other main use for this pattern, synchronization. The mayor is doing the best he can, but even he needs help saving his city. <span name="pun">To disk</span>, that is.</p>
<aside name="pun">

<p>If you&#x2019;re reading this awful pun, that means I managed to maintain the bad judgement to keep this in through each revision of this chapter. What was I thinking?</p>
</aside>

<p>Our player is going to spend hours meticulously crafting their city. They probably don&#x2019;t want to just throw it out the window and start over from scratch every time they quit the game, so we&#x2019;ll want to whip up some kind of save-load system.</p>
<p>Obviously, saving the city to disk every time they plant a single mailbox or lightpost would be numbingly slow and cause undo torture to the player&#x2019;s hard disk. A better solution is to save when they quit the game.</p>
<p><span name="elide"></span></p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">quit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">city</span><span class="p">.</span><span class="n">save</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<aside name="elide">

<p>Like many chapters in this book, I&#x2019;m eliding the concrete code to actually save the city. Since we&#x2019;re just concerned with the architectural structure here, the implementation details are, well, implementation details.</p>
</aside>

<p>Swell. Now every time the player quits the game, they&#x2019;re beautiful metropolis is lovingly enscribed on the platters of their hard disk, ready and waiting for the next time the game is run. Alas, this isn&#x2019;t a perfect solution.</p>
<h3><a href="#wasting-time-in-a-clean-city" name="wasting-time-in-a-clean-city">Wasting time in a clean city</a></h3>
<p>The problem is that in our awesome game, you can build huge cities. Writing out every street and telephone pole takes a long time. When they player&#x2019;s actually built lots of new stuff, there&#x2019;s not much you can do. But if they just open the city, look around a bit and quit, it&#x2019;s pointless to save the city: nothing&#x2019;s changed and the city on disk is already up to date.</p>
<p>We&#x2019;ll apply this pattern and define a dirty flag for the city:</p>
<div class="codehilite"><pre><span class="n">class</span> <span class="n">City</span> <span class="p">{</span>
  <span class="c1">// Lots of other stuff&amp;hellip;</span>
<span class="nl">private:</span>
  <span class="kt">bool</span> <span class="n">dirty</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Now when we go to save, we&#x2019;ll first check and see if we have to:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">save</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Bail if the city is already up to date.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Write city to disk&amp;hellip;</span>

  <span class="c1">// The city on disk is up to date now.</span>
  <span class="n">dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3><a href="#getting-dirty" name="getting-dirty">Getting dirty</a></h3>
<p>This is the easy part. The hard part is making sure that flag gets set. Every bit of code that modifies a part of the city&#x2019;s state that is saved to disk needs to make sure to set dirty to true. You can imagine lots of methods like:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">zoneArea</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Set zoning&amp;hellip;</span>
  <span class="n">dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">placeBuilding</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Building</span> <span class="n">building</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Place building&amp;hellip;</span>
  <span class="n">dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">addRoad</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Direction</span> <span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Add road&amp;hellip;</span>
  <span class="n">dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>If you have a <span name="wide">wide smear</span> of code that modifies state, you&#x2019;re just asking to make a mistake and forget to set the dirty flag somewhere. If you can, it helps to define that code in terms of a much smaller interface that does the low-level modification.</p>
<aside name="wide">

<p>In general, code that <em>modifies</em> state is more problematic than code that just <em>reads</em> state. Whenever you&#x2019;re trying to understand a chunk of code, you have to think about what state the data is in, how it got that way, and how it can change. When other random code reads that state, it doesn&#x2019;t affect your local understanding of what that code does. But when outside code can <em>change</em> the state, now you have to hold that much larger context in your head.</p>
</aside>

<p>For example, in our city-building game, the city is ultimately represented by a grid of tiles. Roads, buildings, and other stuff are all just different kinds of tiles. Given that, we could define a low-level method like:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">setTile</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Tile</span> <span class="n">tile</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Change tile data&amp;hellip;</span>
  <span class="n">dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This method makes sure to set the dirty flag. Then the previous high level modification methods can be implemented using it:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">zoneArea</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">top</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">+</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">top</span> <span class="o">+</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">setTile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">TILE_ZONE</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">placeBuilding</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Building</span> <span class="n">building</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">setTile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">building</span><span class="p">.</span><span class="n">tile</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">addRoad</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Direction</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Tile</span> <span class="n">tile</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="n">DIR_HORIZONTAL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">tile</span> <span class="o">=</span> <span class="n">TILE_HOR_ROAD</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">tile</span> <span class="o">=</span> <span class="n">TILE_VERT_ROAD</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">setTile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">tile</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Notice that now none of these methods have to worry about the dirty flag. The more we can push setting the dirty flag into lower-level code, the fewer places we&#x2019;ll have to worry about it, and the less likely we are to forget.</p>
<h3><a href="#dirty-parts-of-town" name="dirty-parts-of-town">Dirty parts of town</a></h3>
<p>We&#x2019;re in a pretty good place now, but our game is a bit old school. Why save to <em>disk</em> when you can save to the <em>cloud</em>. That way, the player can seamlessly play in the same city on their computer, phone and tablet. Exciting!</p>
<p>But this means saving they&#x2019;re changes will take even longer: we&#x2019;ll have to push all of the data for the city over the network. Not only is it slow, it&#x2019;s a waste of bandwidth. Users on limited data plans won&#x2019;t be happy when our game burns through their allotment.</p>
<p>It&#x2019;s time to start thinking about the <em>granularity</em> of our dirty state. Right now, we have a single bit for the entire city. It&#x2019;s either completely out of date, or completely up to date. But in practice, <em>most</em> of the city is unchanged and only a couple of pieces have been modified.</p>
<p>We can do something more sophisticated by having finer-grained dirty bits. We&#x2019;ll divide the city into <em>blocks</em>&thinsp;&mdash;&thinsp;regions of some fixed size&thinsp;&mdash;&thinsp;and associated a dirty flag with each block. Something along the lines of:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">setTile</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Tile</span> <span class="n">tile</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Change tile data&amp;hellip;</span>

  <span class="c1">// Mark this block dirty.</span>
  <span class="n">setDirtyFlag</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">BLOCK_SIZE</span><span class="p">,</span> <span class="n">y</span> <span class="o">/</span> <span class="n">BLOCK_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Internally, <code>City</code> will keep some kind of array of dirty bits, one for each block. When we go to save the city to the game servers, we just send the dirty blocks:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">City</span><span class="o">::</span><span class="n">save</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">CITY_SIZE</span> <span class="o">/</span> <span class="n">BLOCK_SIZE</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">CITY_SIZE</span> <span class="o">/</span> <span class="n">BLOCK_SIZE</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">isDirty</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
      <span class="p">{</span>
        <span class="c1">// Upload block (x, y) to server&amp;hellip;</span>
        <span class="n">clearDirtyFlag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>There&#x2019;s a small amount of overhead to doing things this way. Because we&#x2019;re only saving pieces of the city, we have to send along a bit of metadata with each block to identify it. That way the server knows which pieces of the city its getting.</p>
<p>The trick then is to tune our granularity. If we make the blocks too small, this additional metadata will add more overhead than the savings we got from not having send the whole city. On the other hand, if we make the blocks too big, we end up sending larger amounts of unchanged data. Like all optimizations, we&#x2019;ll have to tune this based on some empirical data for our specific game.</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<p>This is a pretty concrete pattern, so it isn&#x2019;t that open-ended. There are only a couple of things to tune with it:</p>
<h3><a href="#when-is-the-dirty-flag-cleaned" name="when-is-the-dirty-flag-cleaned">When is the dirty flag cleaned?</a></h3>
<p>The most basic question you&#x2019;ll have to answer is when to actually do the work you&#x2019;ve deferred. You can&#x2019;t defer it <em>forever</em>, after all. Here&#x2019;s a few options from least to most eager.</p>
<ul>
<li>
<p><strong>If you defer it until the result is needed:</strong></p>
<ul>
<li>
<p><em>It avoids doing calculation entirely if the result is never used.</em> For
    primary data that changes frequently and where the derived data is
    rarely accessed, this can be a huge win.</p>
</li>
<li>
<p><em>If the calculation is time-consuming, it can cause a noticeable pause.</em>
    Postponing the work until the end-user is waiting to see the result can
    affect their gameplay experience. Often, it&#x2019;s fast enough that this
    isn&#x2019;t a problem, but if it is, you&#x2019;ll have to do the work earlier.</p>
</li>
</ul>
</li>
<li>
<p><strong>At well-defined checkpoints:</strong></p>
<p>Sometimes there is a point in time or the progression of the game where it&#x2019;s
natural to do the deferred synchronization or calculation. For example, you
may want to delay saving the game until the player reaches some kind of
check point in the level.</p>
<p>These synchronization points may not be user visible or part of the game
mechanics. For example, maybe there&#x2019;s a loading screen or a cut scene that
you can hide the work behind.</p>
<ul>
<li>
<p><em>You can ensure the time spent doing the work doesn&#x2019;t impact the user
    experience.</em> Unlike the above option, you can often give something to
    distract the player while the game is busy on other things.</p>
</li>
<li>
<p><em>You lose control of when the work actually happens.</em> This is sort of the
    opposite of the above point. You have micro-scale control over when the
    work happens, and can make sure the game handles it gracefully.</p>
<p>What you <em>can&#x2019;t</em> do is ensure the player actually makes it to the
checkpoint or meets whatever criteria you&#x2019;ve defined. If they get lost
or the game gets in a weird state, you can end up deferring the work
longer than you expected.</p>
</li>
</ul>
</li>
<li>
<p><strong>In the background:</strong></p>
<p>Like your text editor that auto-saves a backup every few minutes, you can
do the work on some fixed time interval. Usually, you&#x2019;ll kick off the timer
on the first modification and the process all of the changes that happened
between then and when the timer fires. Then you reset and start all over
again.</p>
<ul>
<li>
<p><em>You can tune how frequently the work is performed.</em> Here the timing of
    when we clean the dirty state and perform the work isn&#x2019;t dependent on
    the player requesting some data or reaching some checkpoint, so we can
    ensure it happens as frequently (or infrequently as we want).</p>
</li>
<li>
<p><em>You can do more redundant work.</em> If the primary state only changes a
    tiny amount during the timer&#x2019;s run, and the granularity of our dirty
    flags is too coarse, we&#x2019;ll do work on a bunch of data that hasn&#x2019;t
    changed. If tiny changes trickle in, that timer will constantly be
    running and triggering work over data again and again that hasn&#x2019;t
    changed much.</p>
</li>
<li>
<p><em>You can end up throwing away work.</em> The timer starts at the beginning
    of the first change to the primary data, and fires at some fixed
    interval after that. If the primary data is still being changed (i.e.
    the mayor is still in a zoning frenzy) when the timer goes off, we&#x2019;ll
    do the processing, and then immediately start the timer again and throw
    out what we just did since changes are still coming in.</p>
<p>If that happens often, it may make sense for the timer to be more
adaptive. One fix is to reset the timer on <em>every</em> change, not just the
first. This means it will do the processing after a fixed amount of time
has passed <em>where the primary state hasn&#x2019;t changed</em>.</p>
<p>This helps you avoid pointless work, at the expense of running the risk
of deferring too long. Imagine a player feverishly building for hours
on end without a break. The timer will keep getting reset and never
actually auto-save the city.</p>
</li>
<li>
<p><em>You&#x2019;ll need some support for doing work "in the background".</em>
    Processing on a timer independent of what the player is doing implies
    the player can keep doing whatever that is while the processing is
    going on. After all, if the processing was so fast that we could do it
    synchronously while they played, we wouldn&#x2019;t need this pattern to begin
    with.</p>
<p>That does mean we&#x2019;ll need threading or some other kind of concurrency
support so that the work we&#x2019;re doing can happen while the game is still
responsive and being played. Since the player is also interacting with
the state that you&#x2019;re processing, you&#x2019;ll need to think about making that
safe for concurrent modification too.</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#how-fine-grained-is-your-dirty-tracking" name="how-fine-grained-is-your-dirty-tracking">How fine-grained is your dirty tracking?</a></h3>
<p>In our first sample, we had a single flag for the entire city. We improved performance at the expense of some complexity and overhead by changing that to track a dirty bit for each block in the city. Depending on your use case, you may have options like that too.</p>
<ul>
<li>
<p><strong>If it&#x2019;s more coarse-grained:</strong></p>
<ul>
<li>
<p><em>It&#x2019;s simpler.</em> You don&#x2019;t have to spend as much time determining which
    <em>part</em> of the state is dirty. The code for doing the work can do it
    in one monolithic chunk instead of needing to be able to handle
    chewing on smaller isolated pieces of state.</p>
</li>
<li>
<p><em>There&#x2019;s less overhead for tracking what is dirty.</em> You&#x2019;ll spend less
    memory on the dirty flags themselves (though that&#x2019;s almost always
    a trivial expense). When you go to process the dirty state and do
    the work, you&#x2019;ll need less metadata to express what subset of the
    data is dirty.</p>
</li>
</ul>
</li>
<li>
<p><strong>If it&#x2019;s more fine-grained:</strong></p>
<ul>
<li>
<p><em>You need to be able to process a subset of the data.</em> In our trophy
    room example, there&#x2019;d by no way to split it into several narrower
    dirty flags. Since adding a single trophy can change the entire
    layout, the processing we have to do has to be a single monolithic
    operation that takes all trophies into account.</p>
<p>In order to do finer-grained dirtiness-tracking, you&#x2019;ll need to make
sure the work you have to do is amenable to being decomposed like
that.</p>
</li>
<li>
<p><em>You&#x2019;ll less more time working on unchanged data.</em> A coarse-grained
    dirty flag invalidates a larger swath of data, much of which may be
    unchanged. With finer-grained tracking, you only mark the data
    that&#x2019;s actually different and thus only process actual changes.</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<ul>
<li>
<p>This pattern is increasingly common outside of games in client-side MVC web frameworks like <a href="http://angularjs.org/">Angular</a> which use dirty flags to track which data has been changed in the browser and needs to be pushed up to the server.</p>
</li>
<li>
<p>Physics engines keep track of which objects are resting and which are in motion. Since a resting body won&#x2019;t move until an impulse is applied to it, they don&#x2019;t need any processing until they get touched. This "is resting" bit is essentially a dirty flag to track which objects have had forces applied and need to have their physics resolved.</p>
</li>
</ul>
<p class="footer">&copy; 2009-2013 Bob Nystrom</p>
</div>
</body>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</html>
