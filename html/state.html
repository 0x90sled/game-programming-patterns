<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Game Programming Patterns / Design Patterns Revisited / State</title>

        <!-- Tell mobile browsers we're optimized for them and they don't need to crop the viewport. -->
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
        <link rel="stylesheet" type="text/css" href="style.css" />
        <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
        </head>
        <body id="top">
        <div class="content">
<h1 class="book"><a href="index.html">Game Programming Patterns</a> / Design Patterns Revisited</h1>
<h1>State</h1>
<ul>
<li>this chapter is a two-fer</li>
<li>the "state pattern" in design patterns is one way to implement a certain
  higher-level pattern. it&#x2019;s a "design pattern" but in many ways its more
  an implementation pattern.</li>
<li>the higher level pattern is "finite state machines"</li>
<li>weird corner of cs that&#x2019;s familiar to game developers (especially ai) compiler writers, and almost no one else</li>
<li>we&#x2019;ll cover both here and a bit about some variations and limitations</li>
</ul>
<h2><a href="#we've-all-been-there" name="we've-all-been-there">We've all been there</a></h2>
<ul>
<li>start coding input handling your player-controlled character</li>
<li>left and right button presses make run left and right</li>
<li>charge makes it start charging powerup</li>
<li>need to keep track of how long you&#x2019;ve been charging, so add chargeTime</li>
<li>releasing charge cancels</li>
<li>unless its full in which case it uses power</li>
<li>wait, can&#x2019;t move left and right if charging, so need to check chargeTime there</li>
<li>jump button makes it start jumping</li>
<li>can&#x2019;t double jump, so add isJumping</li>
<li>cancels charge if you jump while charging</li>
<li>can move left and right while jumping, but not charge while jumping</li>
<li>then you add ducking, and attacking, and getting hit</li>
<li>you end up with a slew of flags, many combinations of which are invalid
  (what does it mean if you&#x2019;re ducking and jumping at the same time?)</li>
<li>you keep finding bugs where you didn&#x2019;t consider what happens when some button is pressed in some weird state</li>
<li>add longer and deeper chains of ifs</li>
<li>in exasperation, you get out a notebook and scribble a flowchart</li>
<li>ta-da, you just invented finite state machines</li>
</ul>
<h2><a href="#finite-state-machines-to-the-rescue" name="finite-state-machines-to-the-rescue">Finite state machines to the rescue!</a></h2>
<ul>
<li>after getting overwhelmed by a sea of booleans and huge branches, you cleared your head and realized</li>
<li>character can be in one of a few set of states: standing, running, charging, jumping, ducking</li>
<li>set of states is <em>finite</em>: you can list them out</li>
<li>each state is what character "is doing". can only be in one at a time</li>
<li>the way a button press is handled is determined completely by the state</li>
<li>a state can handle a button press by doing a couple of things:</li>
<li>executing some chunk of code like firing the powerup, or changing velocity to jump</li>
<li>transitioning to another state</li>
<li>you grab a notebook and draw boxes for each state</li>
<li>you draw lines between each box and label them with buttons</li>
<li>these are the button presses that cause a transition to that state</li>
<li>
<p>you also jot down notes about behavior that happens when changing state</p>
</li>
<li>
<p>(like old text adventure: state is where you are, transitions are "go north", etc.)</p>
</li>
<li>
<p>this is a fsm: you have a set of states</p>
</li>
<li>when inputs come in:<ul>
<li>they can cause some behavior</li>
<li>and may cause a state transition</li>
</ul>
</li>
<li>otherwise, the input is ignored</li>
<li>but how to code?</li>
</ul>
<h2><a href="#switch" name="switch">Switch</a></h2>
<ul>
<li>go back to code. realize first problem is that you have a bunch of bools, when you really just need an enum</li>
<li>if ever have handful of bools, only one of which can be true at a time, sign you need enum</li>
<li>make enum for states</li>
<li>give character field that is enum value of current state</li>
<li>then instead of ifs, you can switch</li>
<li>changing state just means setting field to new enum value</li>
<li>congrats, this the is the simplest way to implement a state machine.</li>
<li>it&#x2019;s legit, despite what gof may have you believe.</li>
<li>not perfect, though</li>
<li>big switches can get hairy, especially if you keep adding states</li>
<li>smears code for one state across class<ul>
<li>you have all of the input handling code for all states in one place and updating code in another, and the rendering code in another...</li>
<li>might be easier if you had all of the code for one state together: input handling, updating, and rendering</li>
</ul>
</li>
<li>character has this "chargeTime" field, but it&#x2019;s only meaningful in charging state<ul>
<li>in other state, it has no value and isn&#x2019;t well-defined</li>
</ul>
</li>
</ul>
<h2><a href="#gof-state-pattern" name="gof-state-pattern">GoF State pattern</a></h2>
<ul>
<li>brings us to the gof pattern</li>
<li>hardcore oop guys will never use a conditional or a switch when they can use virtual dispatch</li>
<li>[gof comes from smalltalk where conditionals <em>are</em> virtual dispatch]</li>
<li>you can def go too far, but there&#x2019;s sense there</li>
<li>the state pattern says, take those switch cases and replace them with classes</li>
<li>define an abstract class that represents the current state the character is in</li>
<li>each state (standing, running, charging, etc.) is a subclass</li>
<li>
<p>each switch, each place where behavior varied by state, becomes a virtual method</p>
</li>
<li>
<p>pros</p>
</li>
<li>each state is nicely encapsulated</li>
<li>can have state-specific... state<ul>
<li>can move that chargetime field out of character into charging state</li>
<li>when not in that state, field doesn&#x2019;t exist</li>
<li>nice and neat</li>
</ul>
</li>
<li>easier to maintain when you have lots of states</li>
<li>cons</li>
<li>
<p>lot more complex</p>
<ul>
<li>especially in languages like c++ where it takes a good bit of code to
  define a class, lot of boilerplate</li>
</ul>
</li>
<li>
<p>sounds a lot like strategy or type object</p>
</li>
<li>mechanics are same (delegate some part of self to object)</li>
<li>intent is different</li>
<li>strategy is given from outside<ul>
<li>about decoupling class from behavior</li>
<li>doesn&#x2019;t usually change after creation</li>
<li>class referring to strategy may not be aware of strategy implementations</li>
</ul>
</li>
<li>state subclasses are usually relatively well coupled to main class<ul>
<li>focus is on <em>changing</em> state during lifetime of obj</li>
</ul>
</li>
<li>type object is about delegating attributes as much as behavior</li>
<li>state = "what am i doing right now"</li>
<li>strategy = "how do i do it"</li>
<li>type object = "what kind of thing am i"</li>
</ul>
<h2><a href="#where-do-the-states-come-from" name="where-do-the-states-come-from">Where do the states come from?</a></h2>
<ul>
<li>have to figure out where to store instances of state</li>
<li>static ones<ul>
<li>if states don&#x2019;t have any additional state (like charge time), no need
  to make more than one instance of each state</li>
<li>all you really need is a vtable</li>
<li>can just make since static instance</li>
<li>this is flyweight pattern</li>
<li>for love of god, don&#x2019;t bother with a singleton</li>
</ul>
</li>
<li>if state does have state, may need one for each stateful entity<ul>
<li>then have to decide if you instantiate every time change state, or
  reuse</li>
<li>instantiating can churn memory and be slow</li>
<li>reuse means hanging onto them somehow</li>
<li>more frequently state changes, more you want to avoid allocating on
  each state change</li>
</ul>
</li>
<li>personally, prefer static ones</li>
<li>
<p>if do need per-instance ones, good candidate for obj pool</p>
</li>
<li>
<p>talk about other implementations using tables or function pointers?</p>
</li>
</ul>
<h2><a href="#or-don't-code-it-at-all" name="or-don't-code-it-at-all">Or don't code it at all</a></h2>
<ul>
<li>one reason fsms got popular in games is because the boxes-and-lines way of
  modeling them is straightforward enough non-programmers can build them</li>
<li>there are tools out there that will let you build fsms visually</li>
<li>worked on games where designers drew flowcharts in program to create behavior</li>
</ul>
<h2><a href="#too-good-to-be-true" name="too-good-to-be-true">Too good to be true</a></h2>
<ul>
<li>this is a really cool little concept. if you&#x2019;ve ever gone from spaghetti code
  to drawing out the clean flowchart and coding it up, it really does feel like
  a breath of fresh air.</li>
<li>like an informercial for ginzu knives, makes it seem like everything is just
  so easy!</li>
<li>
<p>alas, reality isn&#x2019;t as nice as commercials</p>
</li>
<li>
<p>first, has weird problem kind of like commercial.</p>
</li>
<li>know how every commercial starts with hapless consumer struggling without
    product?</li>
<li>fsms are like that, always seem to muddle through without them before
    realizing you need one</li>
<li>but then you&#x2019;ve got a good amount of code to rewrite</li>
<li>but if you just use state pattern up front, it can be overkill</li>
<li>gof state pattern is a big jump in code complexity over a basic switch</li>
<li>totally overkill if you just have a few states and transitions</li>
<li>
<p>just get used to idea you may need to refactor</p>
<ul>
<li>when fsm works well, it&#x2019;s often so much clearer its worth the effort</li>
</ul>
</li>
<li>
<p>appeal of fsms is that they are very rigid and constrainted: once you draw
  those boxes and lines, you&#x2019;ve instantly got a clear picture of how your
  program works</p>
</li>
<li>easy to reason about</li>
<li>
<p>easy to debug</p>
</li>
<li>
<p>problem though, is it is actually quite constrained, often too constrained</p>
</li>
<li>basically have to reduce all of your state to a single number</li>
<li>not even turing complete</li>
<li>can lead to combinatorial explosion</li>
<li>because of this, game programmers go beyond restricted cs formal defn of fsm
  in a bunch of ways</li>
<li>walk through some problems and show common ways to solve them</li>
</ul>
<h2><a href="#concurrent-machines-buy-one,-get-one-free" name="concurrent-machines-buy-one,-get-one-free">Concurrent machines: Buy one, get one free</a></h2>
<ul>
<li>character can equip gun</li>
<li>gun can be fired while running or jumping</li>
<li>after firing, it has to recharge</li>
<li>if you try to mix into main state machine, have lots of dupe states:
  jumping, jumping with charging gun, jumping with charged gun, etc.</li>
<li>have set of states for character, and set of states for gun</li>
<li>to represent all possible states in one fsm, have to have every combination
  (pair) of states</li>
<li>better is to have two independent state machines running in parallel</li>
<li>gun state machine is just charging -&gt; charged</li>
<li>some amount of coordination between them</li>
<li>jump and run states will need to check gun state to see if character can fire</li>
<li>not theoretically perfect, but works: just like game devs do</li>
</ul>
<h2><a href="#hierarchical-state-machines-inheritance-for-states" name="hierarchical-state-machines-inheritance-for-states">Hierarchical state machines: inheritance for states</a></h2>
<ul>
<li>lets say we break out running states a bit in order to have better animations:
  can be standing, walking, running, sliding</li>
<li>in any of those states, pressing jump button starts a jump</li>
<li>fire button shoots</li>
<li>would be nice to not have to copy that code for each state</li>
<li>one solution is hierarchical state machine (hsm)</li>
<li>states can be substates and have superstates</li>
<li>like subclass superclass relationship</li>
<li>when an event comes in, if the substate doesn&#x2019;t handle it, it rolls up to super</li>
<li>in other words, just like inherited methods that aren&#x2019;t overridden</li>
<li>can also handle events in substate to override</li>
<li>so we&#x2019;ll define a "on ground" superstate</li>
<li>standing, walking, running, and sliding will all be substates</li>
<li>on ground has code for jumping and others inherit it</li>
<li>note: has many same problems as inheritance: substates tightly coupled to super</li>
</ul>
<h2><a href="#pushdown-automata-a-stack-of-states" name="pushdown-automata-a-stack-of-states">Pushdown automata: A stack of states</a></h2>
<ul>
<li>another problems with fsms is they have no memory</li>
<li>know what state <em>are</em> in, but not what states you <em>were</em> in</li>
<li>
<p>as soon as you leave a state, forget all about it</p>
</li>
<li>
<p>say we want to be able to pause the game</p>
</li>
<li>add new state for paused</li>
<li>when that state is entered, stop game simulation, but keep listening for input</li>
<li>so game can be unpaused</li>
<li>can pause at any point, so character can be in any state when going to pause
  state (good place to consider hsm)</li>
<li>when you unpause, needs to go back to state character was in</li>
<li>if we do strict fsm, would have to have state for each one: paused-when-running, paused-when jumping, etc.</li>
<li>awful</li>
<li>instead, we&#x2019;ll store <em>stack</em> of states</li>
<li>current state is state on top of stack</li>
<li>can transition from one state to another by replacing top state like normal</li>
<li>but can also <em>push</em> a state</li>
<li>transitions to new state</li>
<li>but leaves previous state under it on stack</li>
<li>to go back, can pop state</li>
<li>pausing <em>pushes</em> pause state</li>
<li>
<p>resuming just pops it</p>
</li>
<li>
<p>can be used for ai where you want to interrupt what an npc is doing like it hears a sound while patrolling, and then have it go back to what it was doing afterwards</p>
</li>
<li>also good for ui where menu screens are often naturally stack-like with forward and back</li>
</ul>
<h2><a href="#but-wait,-there's-more" name="but-wait,-there's-more">But wait, there's more</a></h2>
<ul>
<li>above refinements are very common</li>
<li>actually pretty rare to see a totally vanilla fsm</li>
<li>but they still aren&#x2019;t a silver bullet</li>
<li>even with those extensions, fsms are still pretty rigid and verbose</li>
<li>good fit for thing like network protocol, input handling, simple ai</li>
<li>but for game ai, which was where fsms first became popular, industry is moving away from them towards more flexible systems like behavior trees or planning systems</li>
<li>good to understand fsms as a way to decompose and think about problems</li>
<li>occassionally useful to actually implement, but often more just a mental tool</li>
</ul>
<p><strong>misc notes:</strong></p>
<p>"Allow an object to alter its behavior when its internal state changes. The object will appear to change its class."</p>
<ul>
<li>state machines are related to update steps</li>
<li>often need to split behavior across a series of update calls</li>
<li>need to remember what you were doing</li>
<li>that&#x2019;s its "state"</li>
<li>ditto for networking where stuff happens asynchronously</li>
<li>
<p>generally good for systems where you need to interrupt and resume them where you left off</p>
</li>
<li>
<p>compare flyweight states versus per-instance states</p>
</li>
<li>
<p>consider raw function pointers as states</p>
</li>
<li>
<p>can be too deterministic and lead to predictable behavior</p>
</li>
<li>
<p>can fix this by making them non-deterministic</p>
<ul>
<li>transition to one of a couple of randomly chosen states</li>
</ul>
</li>
<li>
<p>http://www.richardlord.net/blog/finite-state-machines-for-ai-in-actionscript</p>
</li>
<li>http://en.wikipedia.org/wiki/UML_state_machine#Hierarchically_nested_states</li>
<li>http://sourcemaking.com/design_patterns/state</li>
<li>http://en.wikipedia.org/wiki/Pushdown_automaton</li>
<li>http://aigamedev.com/open/article/fsm-age-is-over</li>
<li>http://www.skorks.com/2011/09/why-developers-never-use-state-machines/</li>
<li>http://jessewarden.com/2012/07/finite-state-machines-in-game-development.html</li>
<li>https://code.google.com/p/flash-state-engine/</li>
<li>http://gamedev.stackexchange.com/questions/6005/finite-state-machine-in-c</li>
<li>https://sites.google.com/site/behaviortreeeditor/thesis</li>
<li>http://www.state-machine.com/psicc/PSiCC_excerpts.pdf</li>
</ul>
        <p class="footer">&copy; 2009-2013 Robert Nystrom &mdash; Last modified on July 12, 2013</p>
        </div>
        </body>
        <script src="jquery-1.10.1.min.js"></script>
        <script src="script.js"></script>
        </html>
        