<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Game Programming Patterns / Optimizing Patterns / Data Locality</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
</head>
<body id="top">
<div class="content">
<h1 class="book"><a href="index.html">Game Programming Patterns</a> / Optimizing Patterns</h1>
<h1>Data Locality</h1>
<div class="in-progress">
  <span class="dismiss">&times;</span>
  <p><strong>This book is a work in progress!</strong></p>

  <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/game-programming-patterns/issues/new" target="_blank">file a ticket</a>. To know when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="http://gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=0c27329244" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <table>
      <tr>
        <td width="100%">
          <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
        </td>
        <td>
          <div class="spacer"></div>
        </td>
        <td>
          <input type="submit" value="Join" name="subscribe" id="mc-embedded-subscribe" class="button">
        </td>
      </tr>
    </table>
  </form>
  </div>
  <!--End mc_embed_signup-->

  <table width="100%">
    <tr>
      <td width="50%">
        <p>Thank you!</p>
      </td>
      <td width="50%">
        <p class="signature">&mdash; Bob (<a href="https://twitter.com/intent/user?screen_name=munificentbob" target="_blank">@munificentbob</a>)</p>
      </td>
    </tr>
  </table>
</div>
<h2><a href="#intent" name="intent">Intent</a></h2>
<p><em>Optimize processor cache utilization by arranging data in memory in the order that it is used.</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<p>We&#x2019;ve all been lied to. For years, we&#x2019;ve been shown charts where CPU speed keeps going up and to the right. Moore&#x2019;s Law isn&#x2019;t just some historical observation, it&#x2019;s some kind of moral imperative. We software folks shouldn&#x2019;t have to lift a finger to see our programs magically speed up every year.</p>
<p>CPUs have been getting faster (though even that&#x2019;s plateauing now), but the hardware heads failed to mention a little something. Sure, we can process data faster than ever. But we can&#x2019;t <em>get</em> that data faster.</p>
<p><strong>TODO: graph of processor and memory speeds</strong></p>
<h3><a href="#a-data-warehouse" name="a-data-warehouse">A data warehouse</a></h3>
<p>Before your super fast CPU can blow through a ream of calculations, it actually needs to get the data its working on out of main memory and into registers. It turns out that RAM hasn&#x2019;t been keeping up with increasing CPU speeds. Not even close.</p>
<p>With today&#x2019;s typical hardware, it can take <em>hundreds</em> of cycles to fetch a byte of data from <span name="ram">RAM</span>. If each instruction needs some data, and it takes hundreds of cycles just to get a byte of data for that instruction, how is that our CPUs aren&#x2019;t just sitting idle 99% of the time waiting for data?</p>
<p>Actually, they <em>are</em> stuck waiting on memory an astonishingly large fraction of time these days, but it&#x2019;s not as bad as it could be. To explain how, we&#x2019;re going to take a trip to the Land of Overly Long Analogies&hellip;</p>
<aside name="ram">

<p>It&#x2019;s called "Random access memory" because, unlike disc drives, you can theoretically access any piece of it as quick as any other. You don&#x2019;t have to worry about reading things consecutively like you do a disc.</p>
<p>Or, at least, you <em>didn&#x2019;t</em>. As we&#x2019;ll see, RAM isn&#x2019;t so random access anymore either.</p>
</aside>

<p>Imagine you&#x2019;re an accountant in a tiny little office. Your job is to request a box of papers and go through and do some <span name="accountant">accountant</span>-y stuff with them. Add up a bunch of numbers or something. You do this for specific labeled boxes according to some arcane logic that only makes sense to other accountants.</p>
<aside name="accountant">

<p>I probably shouldn&#x2019;t have used a job I know absolutely nothing about in this analogy.</p>
</aside>

<p>You&#x2019;ve been working this job for a while and you&#x2019;ve gotten pretty awesome at it. You can now finish off an entire box of paper in, say, a minute. Impressive, right? On a good day without too many coffee breaks, you should be able to get through about 480 boxes.</p>
<p>There&#x2019;s a little problem though. All of those boxes are stored in a warehouse in a separate building. To get a box, you have to ask the warehouse guy to bring it to you. He goes and gets a forklift and drives around the aisles until he finds the box you want.</p>
<p>It takes him, seriously, an entire day to do this. Not exactly a go-getter. He&#x2019;s the boss&#x2019;s son, so no one&#x2019;s gonna do anything about it. This means that no matter how fast you are, you only get one box a day. The rest of the time, you just sit there and question the life decisions that led to this soul-sucking job instead of following your passion for videogames.</p>
<p>One day, a couple of industrial designers show up. Their job is to improve the efficiency of operations. They make assembly lines and stuff go faster. The boss has noticed how few boxes get processed and he wants some improvement, so he brought in the experts.</p>
<p>After watching you work for a few days, they notice a few things:</p>
<ul>
<li>
<p>Pretty often, when you&#x2019;re done with one box, the next box you request is right
  <span name="next">next</span> to it on the same shelf in the warehouse.</p>
</li>
<li>
<p>Using a forklift to carry a single box of papers is pretty dumb.</p>
</li>
<li>
<p>There&#x2019;s actually a little bit of spare room in the corner of your office.</p>
</li>
</ul>
<aside name="next">

<p>The technical term for often using stuff nearby the thing you just used is <em>locality of reference</em>.</p>
</aside>

<p>They come up with a clever fix. Whenever the warehouse guy gets a box, he&#x2019;ll
actually grab an entire pallet of them. He gets the box you requested, and then
a bunch of boxes that are next to it. He doesn&#x2019;t know if you want those (and, given his work ethic, clearly doesn&#x2019;t care). He just grabs them.</p>
<p>He loads the whole pallet and brings it to you. Ignoring issues of workplace safety, he drives the forklift right in and drops the pallet in the corner of your office.</p>
<p>When you need a new box, now, the first thing you do is see if it&#x2019;s already on the pallet in your office. If it is, great! It just takes you a second to grab it and you&#x2019;re back to crunching numbers. If a pallet holds fifty boxes and you got lucky and all of the boxes you need happen to be on it, you can churn through fifty times more work than you could before.</p>
<p>But, if you need a box that&#x2019;s <em>not</em> on the pallet, you&#x2019;re back to square one. You can only fit one pallet in your office, so your warehouse friend will have to come take that one back and then bring you entirely new one. Tomorrow.</p>
<h3><a href="#a-pallet-for-your-cpu" name="a-pallet-for-your-cpu">A pallet for your CPU</a></h3>
<p>That&#x2019;s a pretty close <span name="analogy">analogy</span> for how CPUs in modern computers work. In case it isn&#x2019;t obvious, you play the role of the CPU. Your desk is the CPU&#x2019;s registers, and the box of papers is the data you can fit in them. The warehouse is your machine&#x2019;s RAM, and that annoying warehouse guy is the bus that pulls data from main memory into registers.</p>
<aside name="analogy">

<p>Why would it be in this chapter if it wasn&#x2019;t a good analogy?</p>
</aside>

<p>If I were writing this chapter thirty years ago, the analogy would stop there. But as chips got faster and RAM&hellip; didn&#x2019;t&hellip; the hardware guys started looking for solutions. What they came up with was <em>CPU caching</em>. Modern chips have a <span name="caches">little chunk</span> of memory right inside the chip. It&#x2019;s small because it has to fit in the chip. The CPU can pull data from this much faster than it can main memory in part because it&#x2019;s physically closer to the registers. The electrons have a shorter distance to travel.</p>
<aside name="caches">

<p>Modern hardware actually has multiple levels of caching, which is what they mean when you hear "L1", "L2", "L3", etc. Each level is larger but slower than the previous. For this chapter, we won&#x2019;t worry about the fact that memory is actually a hierarchy, but it&#x2019;s important to know.</p>
</aside>

<p>This little chunk of memory is called a <em>cache</em> (in particular, the chunk on the chip is your <em>L1 cache</em>) and in my belabored analogy, its part was played by the pallet of boxes. Whenever your chip reads a byte of data from RAM, it automatically grabs the following chunk of contiguous memory&thinsp;&mdash;&thinsp;usually around 64 to 128 bytes&thinsp;&mdash;&thinsp;too and puts it all in the cache. This strip of contiguous memory is called a <em>cache line</em>.</p>
<p>If the next byte of data you need happens to be in that chunk, the CPU reads it straight from the cache, which is <em>much</em> faster than hitting RAM. When it looks for a bit of data and finds it, that&#x2019;s called a <em>cache hit</em>. If it can&#x2019;t find it in the cache and has to go to main memory, that&#x2019;s a <em>cache miss</em>.</p>
<p>There&#x2019;s one important detail I glossed over in the analogy. In the accountant&#x2019;s office, there was only room for one pallet, or one cache line. In a real cache, it has room for a number of cache lines. It&#x2019;s a relatively smaller, fixed number, but it&#x2019;s more than <em>one</em>. The details about how those work is unfortunately out of scope here, but Google "cache associativity" if you want to feed your brain.</p>
<p>So, whenever the CPU needs some data, it looks to see if a cache line containing it is already in the cache. When that fails, and a cache miss occurs, the CPU <em>stalls</em>: it can&#x2019;t process the next instruction because needs data. So it just sits there, spinning its cycles all bored and lonely, for a few hundred cycles until the fetch completes.</p>
<p>Our mission for the rest of this chapter is to figure out how to minimize that happening. Imagine you&#x2019;re trying to optimize some performance critical piece of game code and it looks like this:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_THINGS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">doAbsolutelyNothingFor500Cycles</span><span class="p">();</span>
  <span class="n">things</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">doStuff</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>What&#x2019;s the first change you&#x2019;re going to make to that code? Right. Take out that pointless function, expensive call. That functional call is equivalent to the performance hit of a cache miss. Every time you bounce to main memory, it&#x2019;s like you put a <code>sleep()</code> call in your code.</p>
<h3><a href="#wait,-data-is-performance" name="wait,-data-is-performance">Wait, data is performance?</a></h3>
<p>Now, I&#x2019;ve known about CPU caching and optimizing for it for a long time. It&#x2019;s one of those ideas that I sort of absorbed through osmosis just by being around other programmers. But I didn&#x2019;t have any first-hand experience with it.</p>
<p>Most of my programming background is higher level: I&#x2019;ve done gameplay, a bit of AI, and tons of UI, tools, and shared library kind of stuff. But I&#x2019;m generally not one of those people who spends <span name="weeks">three weeks</span> squeezing another 3 FPS out of the rendering engine. I try to keep myself out of the hot path of the game loop most of the time.</p>
<aside name="weeks">

<p>I have a ton of respect for them, though!</p>
</aside>

<p>Don&#x2019;t get me wrong, I do care about performance too. So when I started to work on this chapter, I spend some time putting together little mini-game-like programs to try to trigger best case and worst case cache usage. I wanted to write benchmarks that would thrash the cache so I could see first-hand how much bloodshed it causes.</p>
<p>The first thing I learned is that it&#x2019;s surprisingly hard to get a clear window into what your cache is doing. Many basic profilers won&#x2019;t show it and since it&#x2019;s just memory access, it doesn&#x2019;t stick out in the profile. It just looks like every line of code is kind of slow.</p>
<p>When I finally got some stuff working, though, I was surprised. Even after hearing of how big a deal it is, there&#x2019;s nothing quite like seeing it with your own eyes. <span name="ymmv">I got a few programs</span> that did the <em>exact same</em> computation. The only difference was how many cache misses and memory thrashing they caused. The worst case was fifty <em>times</em> slower than the best case.</p>
<aside name="ymmv">

<p>There&#x2019;s a lot of caveats here. In particular, different computers have different cache setups so my machine may be different from yours, and dedicated game consoles are very different from PCs which are quite different from mobile devices.</p>
<p>Your mileage will vary.</p>
</aside>

<p>This was a real eye-opener to me. I&#x2019;m used to thinking of performance being an aspect of <em>code</em> not <em>data</em>. A byte isn&#x2019;t slow or fast, it&#x2019;s just a static thing sitting there. But, because of caching, <em>the way you organize things directly impacts performance.</em></p>
<p>The challenge for me now is to wrap that concept up into something that fits into a chapter here. This book tries to be about simple, concrete patterns. It&#x2019;s a recipe book for code.</p>
<p>But optimization for cache usage is a huge topic. I haven&#x2019;t even touched on <em>instruction caching</em>. Remember, code is in memory too and has to be loaded onto the CPU before it can be executed. Someone more versed on the subject could write an entire book on it.</p>
<p>Until you get your hands on that, though, I do think there are a few basic techniques that I can fit in here that will get you started along the path of thinking about how your data structures impact your performance.</p>
<p>What it all boils down to is something pretty simple: Whenever the chip reads some memory, it gets a whole cache line. The more you can use stuff in that <span name="line">cache line, the faster you go</span>. So the goal then is to <em>organize your data structures so that the things you&#x2019;re processing are next to each other in memory</em>.</p>
<aside name="line">

<p>There&#x2019;s a key assumption here, though: single-threadedness. If you are accessing nearby data on <em>multiple</em> threads, it&#x2019;s often faster to have data on <em>different</em> cache lines. If two threads are accessing data so close to each other that they occupy the same cache line, the caches of those two cores have to synchronize with each other, which is costly.</p>
</aside>

<p>If your code is crunching on A then B then C, you want them laid out in memory like this:</p>
<div class="codehilite"><pre><span class="o">+---+---+---+</span>
<span class="o">|</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span> <span class="o">|</span> <span class="n">c</span> <span class="o">|</span>
<span class="o">+---+---+---+</span>
</pre></div>


<p>Note, these aren&#x2019;t <em>pointers</em> to A, B, and C. It&#x2019;s the data for them, right there, all lined up next to each other. As soon as the CPU reads in A, it will start to get B and C too (depending on how big they and how big a cache line is). Since you&#x2019;re working on those next, you&#x2019;re chip is happy and you&#x2019;re happy.</p>
<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<p>Modern CPUs have <strong>caches to speed up memory access.</strong> These can access memory <strong>adjacent to recently accessed memory much quicker</strong>. Take advantage of that to improve performance by <strong>increasing data locality</strong>&thinsp;&mdash;&thinsp;keeping data in <strong>contiguous memory in the order that you process it.</strong></p>
<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<p>Like most optimizations, the first guideline for using it is <em>when you have a performance problem.</em> There&#x2019;s no point wasting time applying this in code that&#x2019;s way off to the side of your core game loop. In fact, doing so has <em>negative</em> value. It makes your code more complex and less flexible.</p>
<p>With this pattern specifically, you&#x2019;ll also want to ensure you reach for it because you have performance problems <em>caused by cache misses</em>. If your code is slow for other reasons, this won&#x2019;t help. There are three golden rules for optimization:</p>
<ol>
<li>Profile.</li>
<li>Profile.</li>
<li>Profile.</li>
</ol>
<p>You&#x2019;ll need something a little more sophisticated than manually instrumenting your code with some profile hooks that just see how much time has elapsed. You really need to see how many cache misses are occurring and where. Fortunately, CPUs expose this information and there are profilers out that there can access it. Also, tools like cachegrind can run your code in a way that simulates the cache and report cache misses.</p>
<p>It&#x2019;s worth spending the time to get one of these working and make sure you understand the (surprisingly complex) numbers it gives you in return. You really don&#x2019;t want to be fumbling around in the dark here. This pattern may cause you to do some major surgery on your data structures. You need a reliable heart monitor so you can ensure you&#x2019;ve actually helped your patient.</p>
<p>That being said, designing your data structures to be cache friendly can have speeding affects on your program. Cache misses <em>will</em> affect the performance of your game, so it&#x2019;s good to be thinking about how cache-friendly your program is throughout the design process.</p>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<p>Many optimizations sacrifice flexibility for speed. We use things like interfaces to insulate parts of the codebase from each other. That makes it easier to change one of these parts without affecting the others. The cost is that code on either side of the interface can make fewer assumptions about what the other side is doing. That&#x2019;s the <em>point</em>: assumptions are coupling.</p>
<p>Performance is often about making things <em>concrete</em>. Many optimization start with "if we assume X then we can&hellip;". Optimizations thrive on specifics. This pattern in particular fights against our desire for abstraction. In C++, using interfaces implies accessing objects through <span name="virtual">pointers or references</span> to objects. But going through a pointer often means hopping across memory, which causes the exact cache misses this pattern tries to avoid. You&#x2019;ll be sacrificing some of your precious interfaces to please this pattern.</p>
<aside name="virtual">

<p>The other half of interfaces is <em>virtual method calls</em>. Those require the CPU to look up an object&#x2019;s vtable, and then find the pointer to the actual method to call there. So, again, you&#x2019;re chasing a pointer and often causing a cache miss, though this time it&#x2019;s an <em>instruction</em> cache miss, since you&#x2019;re loading code onto the CPU.</p>
</aside>

<p>Some people feel focusing on data locality also goes against the grain of object-orientation. In their minds, OOP is about each <em>object</em> taking care of itself. As we&#x2019;ll see, this pattern thrives on dealing with <em>collections</em> of homogenous objects.</p>
<p>Personally, I think OOP is more about each <em>class</em> taking care of its instances, so I believe the nice things we get from OOP like data hiding still apply here. There may be times where you need to open up an object&#x2019;s internal structure more than you would like to please outside code wanting to get at its data directly in a certain order, but I&#x2019;m not enough of an OOP purist to be really bothered like that. As always, there are challenging trade-offs. That&#x2019;s what makes it fun.</p>
<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<p>OK, it&#x2019;s time for a confession. My goal for this part of the chapter was to show you a little skeleton of a game loop that was processing a bunch of game objects. I was going to show a complete example that demonstrated worst case cache usage so you could run it and see for yourself. Then we&#x2019;d optimize so you could see the difference.</p>
<p>What I got instead was a lesson in how tricky controlling cache usage is. Every time I tried to rearrange my sample program into pieces that made sense in the context of the chapter, the cache usage changed dramatically. Cache usage is <em>highly</em> context dependent. Even the order that functions are written in your source file can affect things. This means that a piece of code can have different caching behavior just by putting it in a program with other code.</p>
<p>Instead of trying to shoehorn a teaching sample and a tight benchmark into one single example program, I&#x2019;m going to do something I think is ultimately more useful. Instead of a monolithic example, we&#x2019;ll walk through a few small examples each showing one common technique used to make code more cache friendly.</p>
<h3><a href="#contiguous-arrays" name="contiguous-arrays">Contiguous arrays</a></h3>
<p>Let&#x2019;s start with the quintessential example of re-organizing a game architecture to be more cache friendly. We&#x2019;ll start with a typical <a href="game-loop.html" class="pattern">Game Loop</a> that processes a bunch of game entities that are organizing using the <a href="component.html" class="pattern">Component</a> pattern.</p>
<p>Each game entity has components for AI, physics, and rendering. So you have a game entity something like this:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">GameEntity</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">GameEntity</span><span class="p">(</span><span class="n">AIComponent</span><span class="o">*</span> <span class="n">ai</span><span class="p">,</span>
             <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">,</span>
             <span class="n">RenderComponent</span><span class="o">*</span> <span class="n">render</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">ai_</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">physics_</span><span class="p">(</span><span class="n">physics</span><span class="p">),</span> <span class="n">render_</span><span class="p">(</span><span class="n">render</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">AIComponent</span><span class="o">*</span>      <span class="n">ai</span><span class="p">()</span>      <span class="p">{</span> <span class="k">return</span> <span class="n">ai_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">physics_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">RenderComponent</span><span class="o">*</span>  <span class="n">render</span><span class="p">()</span>  <span class="p">{</span> <span class="k">return</span> <span class="n">render_</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">AIComponent</span><span class="o">*</span>      <span class="n">ai_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics_</span><span class="p">;</span>
  <span class="n">RenderComponent</span><span class="o">*</span>  <span class="n">render_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Each component will have a relatively small amount of state, maybe little more than a few vectors or a matrix, and then a method to <span name="update">update</span> it. The details aren&#x2019;t important here, but imagine something roughly like:</p>
<aside name="update">

<p>Like the name implies, these are a few examples of the <a href="update-method.html" class="pattern">Update Method</a> pattern. Even <code>render()</code> is this pattern, just by another name.</p>
</aside>

<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Goals, mood, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PhysicsComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Rigid body, velocity, mass, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RenderComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Work with and modify state... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Mesh, textures, shaders, etc. ...</span>
<span class="p">};</span>
</pre></div>


<p>The game maintains a big list of pointers to the entities in the world. Each spin of the game loop, this needs to happen:</p>
<ol>
<li>Update the AI components for all of the entities.</li>
<li>Update the physics components for them.</li>
<li>Render them using their render components.</li>
</ol>
<p>Lots of game engines implement that something like this:</p>
<div class="codehilite"><pre><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gameOver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Process AI.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ai</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Update physics.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">physics</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Draw to screen.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">entities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Other game loop machinery for timing...</span>
<span class="p">}</span>
</pre></div>


<p>Before you ever heard of a CPU cache, this looked totally innocuous. But by now you&#x2019;ve got an inkling that something isn&#x2019;t right here. This code hates the cache. It is spitting in the cache&#x2019;s coffee. Here&#x2019;s what it&#x2019;s doing:</p>
<ol>
<li>
<p>We&#x2019;ve got a list of <em>pointers</em> to game entities. For every game entity in the world, we have to traverse that pointer. That&#x2019;s a cache miss.</p>
</li>
<li>
<p>Then the game entity has a pointer to the component. Another cache miss.</p>
</li>
<li>
<p>Then we update the component.</p>
</li>
<li>
<p>Now we go back to step one for <em>every component of every entity in the game</em>.</p>
</li>
</ol>
<p>The scary part here is we have no idea how any of this stuff is laid out in memory. We&#x2019;re completely at the mercy of the memory manager and the order that things happened to be allocated, which, after the game has been running for a while, is anything but clear cut.</p>
<p><strong>TODO: illustration</strong></p>
<p>If our goal here was to take a whirlwhind tour around the game&#x2019;s address space, sort of a 256MB of RAM in 4 Nights!" cheap European vacation package, it would be a fantastic deal. But our goal is to run the game quickly, and <span name="chase">traipsing</span> all over main memory is <em>not</em> the most effective way to do it. Remember that <code>doAbsolutelyNothingFor500Cycles()</code> function? Well this code is calling that <em>all the time</em>.</p>
<aside name="chase">

<p>The term for burning cycles traversing pointers is <em>pointer chasing</em>, which isn&#x2019;t quite as fun as it sounds.</p>
</aside>

<p>Let&#x2019;s do something better. Our first observation is that the only reason we even follow a pointer to get to the game entity is so we can get to a component. <code>GameEntity</code> itself has no interesting state and no useful methods. The components are what the game loop cares about. Game entities are just a means to that end.</p>
<p>So lets cut out the middle man. Instead of a huge tree of game entities and components scattered like stars across the inky darkess of address space, we&#x2019;re going to get back down to Earth. We&#x2019;ll have a big array for each type of component. A flat array of AI components, another for physics, and another for rendering.</p>
<p>Like this:</p>
<div class="codehilite"><pre><span class="n">AIComponent</span><span class="o">*</span> <span class="n">aiComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">AIComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
<span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physicsComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">PhysicsComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
<span class="n">RenderComponent</span><span class="o">*</span> <span class="n">renderComponents</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">RenderComponent</span><span class="p">[</span><span class="n">MAX_ENTITIES</span><span class="p">];</span>
</pre></div>


<p>Let me just stress that these are arrays of <em>components</em> and not <em>pointers</em> to them. The data is all there, nicely lined up. The game loop will then walk these directly:</p>
<div class="codehilite"><pre><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gameOver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Process AI.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">aiComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Update physics.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">physicsComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Draw to screen.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numEntities</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">renderComponents</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">render</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Other game loop machinery for timing...</span>
<span class="p">}</span>
</pre></div>


<p>We&#x2019;ve ditched all of that <span name="arrow">pointer chasing</span>. Instead of skipping around in memory, we&#x2019;re doing a straight crawl straight through contiguous arrays. We&#x2019;re pumping a solid stream of bytes right into the hungry maw of the CPU. In my little synthetic benchmark programs, this made the update loop fifty <em>times</em> faster than the previous example.</p>
<p><strong>TODO: illustration</strong></p>
<aside name="arrow">

<p>One hint that we&#x2019;re doing better here is how few <code>-&gt;</code> operators there are in the new code.</p>
</aside>

<p>Interestingly, we haven&#x2019;t lost much encapsulation here. Sure, the game loop is going straight to the components instead of getting them from game entities. But it was doing that before. It needed to to ensure things were updated in the right order. But each component itself is still nicely encapsulated. It owns its own data and methods. We just changed the way it&#x2019;s used.</p>
<p>This doesn&#x2019;t mean we need to get rid of <code>GameEntity</code> either. We can leave it just as it is with pointers to its components. They&#x2019;ll just point into those arrays. This can still be useful for other parts of the codebase where you want to pass around a conceptual "game entity" and everything that goes with it. The important part is that the performance critical game loop sidesteps that and goes straight to the data.</p>
<h3><a href="#packed-data" name="packed-data">Packed data</a></h3>
<p>Say we&#x2019;re doing a particle system. Following the advice of the previous section, we&#x2019;ve got all of our particles in a nice big contiguous array. Let&#x2019;s wrap it in a little <span name="pool">manager class</span> too:</p>
<aside name="pool">

<p>This is a great example of an <a href="object-pool.html" class="pattern">Object Pool</a> custom built for a single type of object.</p>
</aside>

<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Particle</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Gravity, etc. ... */</span> <span class="p">}</span>
  <span class="c1">// Position, velocity, etc. ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ParticleSystem</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">();</span>
<span class="nl">private:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_PARTICLES</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">numParticles_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Particle</span> <span class="n">particles_</span><span class="p">[</span><span class="n">MAX_PARTICLES</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>A rudimentary update method for the system just looks like this:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticleSystem</span><span class="o">::</span><span class="n">update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numParticles_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>But it turns out that we don&#x2019;t actually need to process <em>all</em> of them all the time. Sometimes particles are disabled, deactivated, culled, offscreen, or otherwise temporarily out of commission. The easy answer is something like this:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numParticles_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isActive</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">particles_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>For every particle, we have to check that flag before we update it. (We could move the check inside <code>update()</code> but that doesn&#x2019;t actually make a difference.) That probably loads the whole particle into the cache. If the particle <em>isn&#x2019;t</em> active, then we just skip over it to the next particle. So loading that particle into the cache was a waste of time.</p>
<p>The more inactive particles there are, the more we&#x2019;re <span name="branch">skipping across memory</span>. The faster we do that, the more cache misses there are between actually doing useful work updating active particles. If that array is large and has <em>lots</em> of inactive particles in it, we&#x2019;re back to just thrashing the cache again.</p>
<p>Having objects in a contiguous array doesn&#x2019;t solve everything if the objects we&#x2019;re actually processing aren&#x2019;t contiguous in it. If it&#x2019;s a foam of inactive objects we have to skip past, we&#x2019;re right back to the original problem.</p>
<aside name="branch">

<p>Savvy low-level coders are probably aware of another problem here. Doing an <code>if</code> check for every particle can cause a <em>branch misprediction</em> and a <em>pipeline stall</em>. In modern CPUs a single "instruction" actually takes several clock cycles. To keep the CPU busy, instructions are pipelined such that the next instructions start processing before the previous one finishes.</p>
<p>To do that, the CPU has to guess which instructions it will be executing next. In straight line code, that&#x2019;s easy, but with flow control, it gets harder. While it&#x2019;s executing the jump instruction for the <code>if</code>, does it guess that the particle is active and start executing the code for the <code>update()</code> call, or does it guess that it isn&#x2019;t?</p>
<p>To handle this, chips do <em>branch prediction</em>: they see which branches your code tends to take and guess that it will do that again. But when the loop is constantly toggling between particles that are and aren&#x2019;t active, that prediction will fail.</p>
<p>Every time it does, it has to ditch the instructions it had started speculatively processing and start over after the first jump instruction is done. The performance hit of this varies widely by machine, but this is why you&#x2019;ll see some coders avoid flow control in hot code.</p>
</aside>

<p>Given the subtitle you just read a minute ago, you can probably infer the solution. Instead of <em>checking</em> the active flag, we&#x2019;ll <em>sort</em> by it. We&#x2019;ll keep all of the active particles in the front of the list. We can also easily keep track of how many active particles there are. Then our update loop is beautiful:</p>
<div class="codehilite"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numActiveParticles_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">update</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>Now we aren&#x2019;t skipping over any data. Every byte that gets sucked into the cache is a piece of an active particle that we actually need to process.</p>
<p>Of course, I&#x2019;m not saying you should actually quicksort the entire collection of particles every frame. That would more than eliminate the gains here. What we want to do is <em>keep</em> the array sorted.</p>
<p>Obviously, the only time it can become less than perfectly sorted is when a particle has been activated or deactivated. We can handle those two cases pretty easily. When a particle gets activated, we move it up to the end of the active particles by swapping it with the first <em>in</em>active one:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticleSystem</span><span class="o">::</span><span class="n">activateParticle</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Shouldn&#39;t already be active!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">numActiveParticles_</span><span class="p">);</span>

  <span class="c1">// Swap it with the first inactive particle</span>
  <span class="c1">// right after the active ones.</span>
  <span class="n">Particle</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">numActiveParticles_</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">numActiveParticles_</span><span class="p">]</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="c1">// Now there&#39;s one more.</span>
  <span class="n">numActiveParticles_</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>To deactivate a particle, of course, we just do the opposite:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">ParticleSystem</span><span class="o">::</span><span class="n">deactivateParticle</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Shouldn&#39;t already be inactive!</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">numActiveParticles_</span><span class="p">);</span>

  <span class="c1">// There&#39;s one fewer.</span>
  <span class="n">numActiveParticles_</span><span class="o">--</span><span class="p">;</span>

  <span class="c1">// Swap it with the last active particle</span>
  <span class="c1">// right before the inactive ones.</span>
  <span class="n">Particle</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">numActiveParticles_</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">numActiveParticles_</span><span class="p">]</span> <span class="o">=</span> <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="n">particles_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Lots of programmers (myself included) have developed allergies to moving things around in memory. Schlepping a bunch of bytes around <em>feels</em> heavyweight in some sense. Pointers feel lightweight in comparison. But when you add in the cost of <em>traversing</em> that pointer, it turns out that your (well, at least my) intuition isn&#x2019;t right on modern hardware any more. In <span name="profile">many cases</span>, it&#x2019;s cheaper to actually move things around in memory so that you can keep the cache full.</p>
<aside name="profile">

<p>This is your friendly reminder to <em>profile</em> when making these kinds of decisions.</p>
</aside>

<p>There&#x2019;s a neat consequence of keeping the particles <em>sorted</em> by their active state. We no longer need to <em>store</em> the active flag at all. It can be determined entirely by its position in the array and the <code>numActiveParticles_</code> counter. That&#x2019;s good: it makes our particle objects smaller, which means we can pack more in our cache lines. And that makes them even faster.</p>
<p>It&#x2019;s not all rosy, though. As you can see from the API, we&#x2019;ve lost a bit of OOP flavor here. You can no longer just call some <code>activate()</code> method on the <code>Particle</code> itself since it doesn&#x2019;t know it&#x2019;s index. Instead, the particle <em>system</em> has this responsibility.</p>
<p>In this case, I&#x2019;m OK with <code>ParticleSystem</code> and <code>Particle</code> being tightly tied like this. I think of them as a single <em>concept</em> spread across two physical <em>classes</em>. It just means accepting the idea that particles are <em>only</em> meaningful in the context of some particle system.</p>
<h3><a href="#hotcold-splitting" name="hotcold-splitting">Hot/cold splitting</a></h3>
<p>OK, this will be the last example of a simple technique for making your cache happier. It&#x2019;s a bit like a finer-grained manifestion of the previous idea. Say we&#x2019;ve got an AI component for some game entity. It has some state in it: the animation it&#x2019;s currently playing, a goal position its heading towards, energy level, etc.. Stuff it checks and tweaks every single frame. Something like:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Animation</span><span class="o">*</span> <span class="n">animation_</span><span class="p">;</span>
  <span class="kt">float</span>      <span class="n">energy_</span><span class="p">;</span>
  <span class="n">Vector</span>     <span class="n">goalPos_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>But it also has some state for rarer eventualities. It may need to store some data describing what loot it drops when it gets 86&#x2019;d. That state will only ever be used once by the game entity&#x2019;s lifetime, right at the bitter end.</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Previous fields...</span>
  <span class="n">LootType</span> <span class="n">drop_</span><span class="p">;</span>
  <span class="kt">int</span>      <span class="n">minDrops_</span><span class="p">;</span>
  <span class="kt">int</span>      <span class="n">maxDrops_</span><span class="p">;</span>
  <span class="kt">float</span>    <span class="n">chanceOfDrop_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Assuming we&#x2019;ve already followed the earlier patterns, when we update these AI components, we&#x2019;ll be walking through a nice packed array of data. But that data includes all of the loot drop information. That makes each component bigger, which reduces the number of them we can fit in a cache line. We get more cache misses because the total memory we walk over is larger. That drop data gets pulled into the cache for every component, every frame, even though we aren&#x2019;t even touching it.</p>
<p>One solution for this is called "hot/cold splitting". The idea is to break our data structure into two separate pieces. The first holds the "hot" data: the state we need to touch every frame. The other piece is the "cold" data: everything else that gets used less frequently.</p>
<p>The hot piece is the <em>main</em> AI component. It&#x2019;s the one we need to use the most, so we don&#x2019;t want to hide it behind an indirection. The cold component can be off to the side, but we still need to get to it, so we give the hot component a pointer to it, like so:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">AIComponent</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="c1">// Methods...</span>
<span class="nl">private:</span>
  <span class="n">Animation</span><span class="o">*</span>   <span class="n">animation_</span><span class="p">;</span>
  <span class="kt">float</span>        <span class="n">energy_</span><span class="p">;</span>
  <span class="n">Vector</span>       <span class="n">goalPos_</span><span class="p">;</span>

  <span class="n">AIComponent</span><span class="o">*</span> <span class="n">cold_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AIComponentCold</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">AIComponent</span><span class="p">;</span>
  <span class="n">LootType</span> <span class="n">drop_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minDrops_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">maxDrops_</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">chanceOfDrop_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Now when we&#x2019;re walking the AI components every frame, the only data that gets loaded into the cache is what we really, with the <span name="parallel">exception</span> of that one little pointer to the cold data. But that&#x2019;s still a real improvement over having all of that cold data right there in the way.</p>
<aside name="parallel">

<p>We could conceivably ditch the pointer too by having parallel arrays for the hot and cold components. Then we can find the cold AI data for an actor as long as we know its index since both pieces will be at the same index in their respective arrays.</p>
</aside>

<p>You can see how this starts to get fuzzy though. In my example here, it&#x2019;s pretty obvious which data should be hot and cold, but it&#x2019;s rarely so clear cut. What if you have fields that are used when an entity is in a certain mode but not in others? What if entities use a certain chunk of data only when they&#x2019;re in certain parts of the level.</p>
<p>Doing this kind of optimization is somewhere between a black art and a rathole. It&#x2019;s easy to get sucked in and spend endless time pushing data around to see what speed difference it makes. It will take some practice to get a handle on when and where it&#x2019;s worth it to focus on this stuff.</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<p>This pattern is really about a mindset: it&#x2019;s getting you to think about where your data is in memory as a critical piece of your game&#x2019;s performance story. The actual concrete design space is wide open. You can let <span name="dod">data locality</span> affect your whole design philosophy, or maybe it&#x2019;s just a localized pattern you apply to a few critical data structures.</p>
<p>The biggest question you&#x2019;ll need to answer is when and where you apply this pattern. But here&#x2019;s a couple specific ones that may come up.</p>
<aside name="dod">

<p>Noel Llopis&#x2019; <a href="http://gamesfromwithin.com/data-oriented-design">famous article</a> that got a lot more people thinking about designing games around data locality and cache-friendliness calls this "data-oriented design".</p>
</aside>

<h3><a href="#how-do-you-handle-polymorphism" name="how-do-you-handle-polymorphism">How do you handle polymorphism?</a></h3>
<p>One thing I&#x2019;ve dodged in this chapter so far is subclassing and virtual methods. We&#x2019;ve been assuming we&#x2019;ve got nice packed arrays of <em>homogenous</em> objects. That way, we know they&#x2019;re all the exact same size. But polymorphism and dynamic dispatch are useful tools, too. How do we merge them?</p>
<p><strong>Don&#x2019;t:</strong></p>
<p>The simplest answer is to just avoid subclassing, or at least avoid it in places where you&#x2019;re optimizing for cache usage. Software engineer culture is drifting away from heavy use of inheritance anyway.</p>
<ul>
<li>
<p><em>It&#x2019;s safe and easy.</em> You know exactly what class you&#x2019;re dealing with and all objects are obviously the same size. If you don&#x2019;t <em>need</em> polymorphism, don&#x2019;t use it.</p>
</li>
<li>
<p><em>It&#x2019;s faster.</em> Dynamic dispatch means looking up the method in the vtable and then traversing that pointer to get to the actual code. That can be an <em>instruction</em> cache miss. While overhead for this varies widely across different hardware, there is a cost to dynamic dispatch.</p>
</li>
<li>
<p><em>It&#x2019;s inflexible.</em> Of course, the reason we use dynamic dispatch is because it gives us a powerful way to make a bunch of different objects behave differently. If you want different entities in your game to have their own AI styles, their own special moves and attacks, virtual methods are a nice way to model that. Having to instead stuff all of that code into a single non-virtual method that does something like a switch on the AI type gets messy quickly.</p>
</li>
</ul>
<p><strong>Use separate arrays for each type:</strong></p>
<p>We use polymorphism so that we can invoke behavior on an object whose type we don&#x2019;t know. In other words, we have a mixed bag of stuff and we want each object in there to do its own thing when we tell it to go.</p>
<p>But that just raises the question of why mix the bag to begin with? Instead, why not just maintain separate homogenous collections for each type?</p>
<ul>
<li><em>It keeps objects tightly packed.</em> Since each array only contains objects of the same type, there&#x2019;s no padding or other weirdness.</li>
<li><em>You can statically dispatch.</em> Once you&#x2019;ve got objects partitioned by type, you don&#x2019;t actually need polymorphism at all any more. You can use regular non-virtual method calls.</li>
<li>
<p><em>You have to keep track of a bunch of collections.</em> If you have a lot of different object types, the overhead and complexity of maintaining separate arrays for each can be a chore.</p>
</li>
<li>
<p><em>You have to be aware of every type</em>. Since you have to maintain seprate collections for each type, you can&#x2019;t be decoupled from them. Part of the magic of polymorphism is that it&#x2019;s <em>open-ended</em>: code that works with an interface can be completely decoupled from the potentially large set of types that implement that interface.</p>
</li>
</ul>
<p><strong>Use a collection of pointers:</strong></p>
<p>If you weren&#x2019;t worried about caching, this is the natural solution. Just have an array of pointers to some base class or interface type. All the polymorphism you could want, and objects can be whatever size they want.</p>
<ul>
<li><em>It&#x2019;s flexible.</em> The code that consumes the collection can work with objects of any type as long as it supports the interface you care about. It&#x2019;s completely open-ended.</li>
<li><em>It&#x2019;s less cache-friendly.</em> Of course, the whole reason we&#x2019;re discussing other options here is because this means cache-unfriendly pointer indirection. But, remember, if this code isn&#x2019;t performance critical, that probably doesn&#x2019;t matter.</li>
</ul>
<h3><a href="#how-are-game-entities-defined" name="how-are-game-entities-defined">How are game entities defined?</a></h3>
<p>If you use this pattern in tandem with the <a href="components.html" class="pattern">Component</a> pattern, you&#x2019;ll have nice contiguous arrays for all of the components that make up your game entity. The game loop will be iterating over those directly, so the actual object representing the game entity itself will be less important, but it&#x2019;s still useful in other parts of the codebase where you want to work with a single conceptual "entity".</p>
<p>The question then is how should it be represented? How does it keep track of its components?</p>
<p><strong>Game entities are classes with pointers to their components:</strong></p>
<p>This is what our first example looked like. It&#x2019;s sort of the vanilla OOP solution. You&#x2019;ve got a class for <code>GameEntity</code>, and it has pointers to the componentes each entity owns. Since they&#x2019;re just pointers, it&#x2019;s agnostic about where and how those components are actually organized in memory.</p>
<ul>
<li><em>You can store components in contiguous arrays.</em> Since the game entity doesn&#x2019;t <span name="care">care</span> where its components are, you can organize them in a nice packed array to optimize iterating over them.</li>
</ul>
<aside name="care">

<p>It&#x2019;s 2:00 AM. Do <em>you</em> know where your components are?</p>
</aside>

<ul>
<li>
<p><em>Given an actor you can easily get to its components.</em> They&#x2019;re just a pointer indirection away.</p>
</li>
<li>
<p><em>Moving components in memory is hard.</em> When components get enabled or disabled, you may want to move them around in the array to keep the components you actually need to process up front and contiguous. If you move a component while the entity has a raw pointer to it, though, that pointer gets broken if you aren&#x2019;t careful. You&#x2019;ll have to make sure to update the entity&#x2019;s pointer at the same time.</p>
</li>
</ul>
<p><strong>Game entities are class with IDs for their components:</strong></p>
<p>The challenge with raw pointers to components is that it makes it harder to move them around in memory. You can address that by having something more abstract: an ID or index that can be used to <em>look up</em> a component.</p>
<p>The actual semantics of the ID and lookup process are up to you. It could be as simple as storing a unique ID in each component and walking the list, or something more complex like a hash table that maps IDs to their current index in the component array.</p>
<ul>
<li>
<p><em>It&#x2019;s more complex.</em> Your ID system doesn&#x2019;t have to be rocket science, but it&#x2019;s still more work than a basic pointer. You&#x2019;ll have to implement and debug it, and there will likely be some memory overhead for bookkeeping.</p>
</li>
<li>
<p><em>It&#x2019;s slower</em>. It&#x2019;s hard to beat traversing a raw pointer. There may be some actual searching or hashing involved to get from an entity to one of its components. This may not matter much, though. Remember, the game loop is working with the components directly so it won&#x2019;t go through this. Code that does need to look up a component given an entity may not be on your hot code path.</p>
</li>
<li>
<p><em>You&#x2019;ll need access to the component "manager".</em> The basic idea is that you have some abstract ID that identifies a component. You can use it to get a reference to the actual component object. But to do that, you need to hand that ID to something that can actually find the component. That will be the class that wraps your raw contiguous array of component objects.</p>
</li>
</ul>
<p>With raw pointers, if you have a game entity, you can find its components. With this, you <span name="singleton">need</span> the game entity <em>and the component registry too</em>.</p>
<aside name="singleton">

<p>You may be thinking, "I&#x2019;ll just make it a singleton! Problem solved!" Well, sort of. You might want to check out <a href="singleton.html">the chapter</a> on those first.</p>
</aside>

<p><strong>The game entity is <em>itself</em> just an ID:</strong></p>
<p>This is a newer style that some game engines use. Once you&#x2019;ve moved all of your entity&#x2019;s behavior and state out of the main class and into components, what&#x2019;s left? It turns out, not much. The only thing an entity does is bind a set of components together. It exists just to say <em>this</em> AI component and <em>this</em> physics component and <em>this</em> render component "go together".</p>
<p>That&#x2019;s important because components interact. The render component needs to know where the entity is, which is likely a property of the physics component. The AI component wants to move the entity, so it needs to apply a force to the physics component. So each component needs a way to get the other sibling components of the entity they are a part of.</p>
<p>Some smart people realized all you need for that is an ID. Instead of the entity knowing its components, the components know their entity. Each component knows the ID of the entity that owns it. When the AI component needs the physics component for its entity, it just asks for the physics component with the same entity ID that it has.</p>
<p>Your entity classes disappear entirely. They just become more or less a typedef for a number.</p>
<p><em>Entities are tiny.</em> When you want to pass around a reference to a game entity, it&#x2019;s literally just a tiny bit of data.</p>
<p><em>Entities are empty.</em> Of course, the downside of moving everything out of entities is that you <em>have</em> to move everything out of entities. You no longer have a place to put non-component-specific state or behavior. This style is basically doubling down on components.</p>
<p><em>You don&#x2019;t have to manage their lifetime.</em> Since entities are just dumb value types, they don&#x2019;t need to be explicitly allocated and freed. A entity implicitly dies when all of its components are destroyed.</p>
<p><em>Looking up a component for an entity may be slow.</em> This is the same problem as the previous answer, but in the opposite direction. To find a component for some entity, you&#x2019;ll have to map an ID to an object. That process may be a bit costly.</p>
<p>This time, though, it <em>is</em> performance critical. Components often interact with their siblings during update, so you will need to find components frequently. One solution is to make the "ID" of an entity just the index of the component in its array.</p>
<p>If every entity has the same set of components, then your component arrays are completely parallel. The component in slot three of the AI component array will be for the same entity that the physics component in slot three of its array is associated with.</p>
<p>Keep in mind, though, that this forces you to keep those arrays in parallel. That&#x2019;s hard if you want to start sorting or packing them by different criteria. For example, you may have some entities with disabled physics and others that are invisible. There&#x2019;s no way to sort the physics and render component arrays optimally for both cases.</p>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<ul>
<li>
<p>Much of this chapter revolves around the <a href="component.html" class="pattern">Component</a>, and that is definitely one of the most common data structures that gets optimized for cache usage. In fact, using the component pattern makes this optimization much easier. Since entities are updated one "domain" (AI, physics, etc.) at a time, splitting them out into components lets you slice a bunch of entities into just the right pieces to be cache-friendly.</p>
<p>But that doesn&#x2019;t mean you can <em>only</em> use this pattern with components! Any time you have performance critical code that touches a lot of data, it&#x2019;s important to think about locality.</p>
</li>
<li>
<p>Tony Albrecht&#x2019;s "<a href="http://research.scee.net/files/presentations/gcapaustralia09/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf">Pitfalls of Object-Oriented Programming</a>)" (PDF) is probably the most widely-read introduction to designing your game&#x2019;s data structures for cache-friendliness. It made a lot more people (including me!) aware of how big a deal this is for performance.</p>
</li>
<li>
<p>Around the same time, Noel Llopis wrote a <a href="http://gamesfromwithin.com/data-oriented-design">very influential blog post</a> on the same topic.</p>
</li>
<li>
<p>This pattern almost invariably takes advantage of a contiguous array of homogenous objects. Over time, you&#x2019;ll very likely be adding and removing objects from that array. The <a href="object-pool.html" class="pattern">Object Pool</a> pattern is about exactly that.</p>
</li>
<li>
<p>The <a href="http://gamadu.com/artemis/">Artemis</a> game engine is one of the first and better-known frameworks that uses simple IDs for game entities.</p>
</li>
</ul>
<p class="footer">&copy; 2009-2013 Bob Nystrom</p>
</div>
</body>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</html>
