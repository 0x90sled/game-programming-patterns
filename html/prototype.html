<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Game Programming Patterns / Design Patterns Revisited / Prototype</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Source+Code+Pro|Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
</head>
<body id="top">
<div class="content">
<h1 class="book"><a href="index.html">Game Programming Patterns</a> / Design Patterns Revisited</h1>
<h1>Prototype</h1>
<div class="in-progress">
  <span class="dismiss">&times;</span>
  <p><strong>This book is a work in progress!</strong></p>

  <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/game-programming-patterns/issues/new" target="_blank">file a ticket</a>. To know when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="http://gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=0c27329244" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <table>
      <tr>
        <td width="100%">
          <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="email address" required>
        </td>
        <td>
          <div class="spacer"></div>
        </td>
        <td>
          <input type="submit" value="Join" name="subscribe" id="mc-embedded-subscribe" class="button">
        </td>
      </tr>
    </table>
  </form>
  </div>
  <!--End mc_embed_signup-->

  <table width="100%">
    <tr>
      <td width="50%">
        <p>Thank you!</p>
      </td>
      <td width="50%">
        <p class="signature">&mdash; Bob (<a href="https://twitter.com/intent/user?screen_name=munificentbob" target="_blank">@munificentbob</a>)</p>
      </td>
    </tr>
  </table>
</div>
<p>Given that this chapter lives under "Design Patterns Revisited", you wouldn&#x2019;t be foolish for assuming this chapter will be all about the <a href="http://en.wikipedia.org/wiki/Prototype_pattern" class="gof-pattern">Prototype design pattern</a>. You would be mistaken, though. Sure, I&#x2019;ll go over that too, but I think prototypes show up in some much more interesting corners of programming these days.</p>
<h2><a href="#prototype-as-a-design-pattern" name="prototype-as-a-design-pattern">Prototype as a Design Pattern</a></h2>
<p>But before we wander abroad, let&#x2019;s cover the <span name="original">original</span> pattern.</p>
<aside name="original">

<p>I don&#x2019;t say "original" lightly here. <em>Design Patterns</em> cites Ivan Sutherland&#x2019;s legendary <a href="http://en.wikipedia.org/wiki/Sketchpad">Sketchpad</a> project in <em>1963</em> as one of the first examples of this pattern in the wild. While everyone else was listening to Dylan and the Beatles, he was busy just, you know, inventing the basic concepts of CAD, interactive graphics, and object-oriented programming.</p>
<p>Watch <a href="http://www.youtube.com/watch?v=USyoT_Ha_bA">the demo</a> and prepare to be blown away.</p>
</aside>

<p>Pretend we&#x2019;re making a game roughly in the style of Gauntlet. We&#x2019;ve got different creatures and fiends swarming around the hero, vying for their share of his flesh. These unsavory dinner companions enter the dungeon by way of generators, and there is a different generator for each kind of monster.</p>
<p>For the sake of this example, let&#x2019;s say we have different classes for each kind of monster in the game. We&#x2019;ll have actual C++ classes for <code>Ghost</code>, <code>Demon</code>, <code>Sorceror</code>, etc., like:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Monster</span>
<span class="p">{</span>
  <span class="c1">// Stuff...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Ghost</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Demon</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Sorceror</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{};</span>
</pre></div>


<p>A generator constructs instances of some monster class. To support every monster in the game, a brute-force solution would be have a generator class for each monster class, leading to a parallel class hierarchy like so:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Generator</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Generator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">generateMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">GhostGenerator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Generator</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Monster</span><span class="o">*</span> <span class="n">generateMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">DemonGenerator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Generator</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Monster</span><span class="o">*</span> <span class="n">generateMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Demon</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// You get the idea...</span>
</pre></div>


<p>Unless you get paid by the line of code, this is pretty obviously not a fun way to solve this problem. Lots of classes, lots of boilerplate, lots of redundancy, lots of duplication, lots of repeating myself&hellip;</p>
<p>The prototype pattern offers a solution. The key idea is that <em>an object can be a generator of other objects similar to itself</em>. If you have a ghost, you can make more ghosts from it. If you have a demon, you can make other demons. Any monster can be treated as a <em>prototypical</em> monster used to spawn other versions of itself.</p>
<p>To implement this, we give our base class, <code>Monster</code>, an abstract <code>clone()</code> method:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Monster</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Monster</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Other stuff...</span>
<span class="p">};</span>
</pre></div>


<p>Each monster subclass provides an implementation that returns a new object identical in class and state to itself. For example:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Ghost</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Monster</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Ghost</span><span class="p">(</span><span class="kt">int</span> <span class="n">health</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">health_</span><span class="p">(</span><span class="n">health</span><span class="p">),</span>
    <span class="n">speed_</span><span class="p">(</span><span class="n">speed</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">Monster</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">(</span><span class="n">health_</span><span class="p">,</span> <span class="n">speed_</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">health_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">speed_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Once all our monsters support that, we no longer need generator classes for each kind of monster. Instead, we define a single generator class:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Generator</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Generator</span><span class="p">(</span><span class="n">Monster</span><span class="o">*</span> <span class="n">prototype</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">prototype_</span><span class="p">(</span><span class="n">prototype</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">Monster</span><span class="o">*</span> <span class="n">generateMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">prototype_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">Monster</span><span class="o">*</span> <span class="n">prototype_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>It internally holds a monster, a hidden one whose sole purpose is to be used by the generator as a template to stamp out more monsters like itself, sort of like a queen bee who never leaves the hive.</p>
<p>To create a ghost generator, we just create a prototypical ghost instance, and then create a generator using that prototype:</p>
<div class="codehilite"><pre><span class="n">Monster</span><span class="o">*</span> <span class="n">ghostPrototype</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">Generator</span><span class="o">*</span> <span class="n">ghostGenerator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Generator</span><span class="p">(</span><span class="n">ghostPrototype</span><span class="p">);</span>
</pre></div>


<p>One neat part about this pattern is that it doesn&#x2019;t just clone the <em>class</em> of the prototype, it clones its <em>state</em> too. This means we could make a generator of fast ghosts, or weak ones, or slow ones, just by creating an appropriate prototype ghost.</p>
<p>I find something both elegant and yet surprising about this pattern. I can&#x2019;t imagine coming up with it myself, but it&#x2019;s such a simple and expressive concept.</p>
<h3><a href="#how-well-does-it-work" name="how-well-does-it-work">How well does it work?</a></h3>
<p>Well, we don&#x2019;t have to create a separate generator class for each monster, so that&#x2019;s good. But we <em>do</em> have to implement <code>clone()</code> in each monster class. That&#x2019;s almost as much code as the separate classes.</p>
<p>There are also some nasty semantic ratholes when you sit down to try to write a correct <code>clone()</code>. Does it do a deep clone or shallow one? (I.e. when a field is itself a reference to an object, do we clone that object, or just the reference?) How does it interact with ownership?</p>
<p>Also, not only does it not look like it&#x2019;s saving us much code in this contrived problem, there&#x2019;s the fact that it&#x2019;s a <em>contrived problem</em>. We had to take as a given that we have separate classes for each monster. These days, that&#x2019;s definitely <em>not</em> the way most game engines roll.</p>
<p>Most of us learned the hard way that big class hierarchies like this are a pain to manage, which is why we instead use patterns like <a href="component.html" class="pattern">Component</a> and <a href="type-object.html" class="pattern">Type Object</a> to model different kinds of entities without enshrining each in its own class.</p>
<h3><a href="#generator-functions" name="generator-functions">Generator functions</a></h3>
<p>Even if we do have different classes for each monster, there are other ways to decorticate this feline. Instead of making separate generator <em>classes</em> for each monster, we could make generator <em>functions</em>, like so:</p>
<div class="codehilite"><pre><span class="n">Monster</span><span class="o">*</span> <span class="nf">generateGhost</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Ghost</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>This is less boilerplate than rolling a whole <em>class</em> for constructing a monster of some type. Then the one generator class can just store a function pointer:</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="n">Monster</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">GenerateCallback</span><span class="p">)();</span>

<span class="k">class</span> <span class="nc">Generator</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Generator</span><span class="p">(</span><span class="n">GenerateCallback</span> <span class="n">generate</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">generate_</span><span class="p">(</span><span class="n">generate</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">Monster</span><span class="o">*</span> <span class="n">generateMonster</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">generate_</span><span class="p">();</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">GenerateCallback</span> <span class="n">generate_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>To create a generator for ghosts, you just do:</p>
<div class="codehilite"><pre><span class="n">Generator</span><span class="o">*</span> <span class="n">ghostGenerator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Generator</span><span class="p">(</span><span class="n">generateGhost</span><span class="p">);</span>
</pre></div>


<h3><a href="#templates" name="templates">Templates</a></h3>
<p>By <span name="templates">now</span>, most C++ developers are familiar with templates. Our generator class needs to construct instances of some type, but we don&#x2019;t want to hard code some specific monster type name. The obvious solution then is to make it a <em>type parameter</em>, which is what templates let us do:</p>
<aside name="templates">

<p>It&#x2019;s hard to tell if C++ programmers learned to love templates, or if templates just scared some of them completely away from C++. Either way, everyone I see using C++ today uses templates too.</p>
</aside>

<p><span name="base"></span></p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Generator</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Generator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">Monster</span><span class="o">*</span> <span class="n">generateMonster</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">GeneratorFor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Generator</span>
<span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Monster</span><span class="o">*</span> <span class="n">generateMonster</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>Using it looks like:</p>
<div class="codehilite"><pre><span class="n">Generator</span><span class="o">*</span> <span class="n">ghostGenerator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GeneratorFor</span><span class="o">&lt;</span><span class="n">Ghost</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>


<aside name="base">

<p>The pair of classes here&thinsp;&mdash;&thinsp;<code>Generator</code> and <code>GeneratorFor</code>&thinsp;&mdash;&thinsp;are so you can have non-templated code that works with a Generator of any type. If we only had the templated <code>GeneratorFor</code> class, there&#x2019;d be no way to write code that accepts a "vanilla" generator of any kind of monster.</p>
<p><code>Generator</code> gives us that single base class that every type-specific generator is derived from. Code that doesn&#x2019;t care what kind of monster a generator emits can use that and avoid needing to be templatized itself.</p>
</aside>

<h3><a href="#first-class-types" name="first-class-types">First-class types</a></h3>
<p>All of these dance around the basic problem which is that we have a class, <code>Generator</code>, that we need to parameterize by a type. Templates are how you do that in C++ because types aren&#x2019;t generally first-class. But if you happen to be using a dynamically-typed language like Smalltalk or Ruby where classes <em>are</em> just regular objects you can pass around, then the natural solution is to do that.</p>
<p>When you make a generator, just pass in the class of monster that it should construct&thinsp;&mdash;&thinsp;literally the actual runtime object that represents the monster&#x2019;s class. Easy as pie.</p>
<p>With all of those other options, I honestly can&#x2019;t say I&#x2019;ve found a case where I felt the prototype <em>pattern</em> was the right answer. So let&#x2019;s put that in our Box of Clever but Not Useful Ideas and talk about something else: prototypes as a <em>language paradigm</em>.</p>
<h2><a href="#prototypes-as-a-language-paradigm" name="prototypes-as-a-language-paradigm">Prototypes as a Language Paradigm</a></h2>
<p>Many people think "object-oriented programming" is synonymous with "classes". While definitions of OOP are subject to endless flamewars, one rough approximation is that it lets you define "objects" which contain both data and behavior. Compared to structured languages like C and functional languages like ML, the defining characteristic of OOP is that it tightly binds state and behavior together.</p>
<p>You may think classes are the one and only way to do that, but a handful of guys in the 80s including Dave Ungar and Randall Smith would beg to differ. They created a language called Self. While as OOP as can be, it had no classes.</p>
<h3><a href="#self" name="self">Self</a></h3>
<p>In many ways, Self is <em>more</em> object-oriented than a class-based language in some pure philosophical sense. We think of OOP as marrying state and behavior, but class based languages actually have a line of separation there.</p>
<p>Consider the semantics of a class-based language. To access some state on an object, you look in the memory for the instance itself. Each instance has the state. To invoke a <span name="vtable">method</span>, though, you look up the instance&#x2019;s class, and then you look up the method <em>there</em>. State lives in instances, and behavior lives in classes. There&#x2019;s always a level of indirection for the latter.</p>
<aside name="vtable">

<p>For example, to invoke a virtual method in C++, you:</p>
<ol>
<li>Find the pointer to the vtable in the object&#x2019;s memory.</li>
<li>From there, look up the method in the vtable.</li>
</ol>
</aside>

<p>Self eliminates that distinction. To look up <em>anything</em>, you just look on the object. An instance can contain both state and behavior. You can have a single object that has a method completely unique to it.</p>
<p>If that was all Self did, it would be hard to use. Inheritance in class-based languages (despite its faults) enables code reuse and lets you avoid code duplication. To do the same without classes, Self has <em>delegation</em>.</p>
<p>To access a field or call a method on some object, we first look in the object itself. If it has it, we&#x2019;re done. If it doesn&#x2019;t, we look at the object&#x2019;s <span name="parent"><em>parent</em></span>. Each object can have a "parent", which is a reference to another object. When we fail to find a property on the object, we try its parent (and its parent, and so on). In other words, failed lookups are <em>delegated</em> to an object&#x2019;s parent.</p>
<aside name="parent">

<p>I&#x2019;m simplifying here. This is a crappy tutorial on Self, but hopefully an OK introduction to prototypes.</p>
</aside>

<p>Parent objects give us a way to reuse behavior (and state!) across multiple objects, so we&#x2019;ve got half of what classes cover here. The other key thing classes do is give us a mechanism to create new instances. When you need a new Thingamabob, you can just do <code>new Thingabob</code> (or whatever your preferred language&#x2019;s syntax is). The class is implicitly a factory for instances of itself.</p>
<p>Without classes, how do we make new things? In particular, how do we make a bunch of new things that all have stuff in common? Just like the design pattern, the way you do this in Self is by <em>cloning</em>.</p>
<p>In Self, it&#x2019;s as if <em>every</em> object supports the Prototype design pattern implicitly. Any object can be cloned. To make a bunch of similar objects, you just:</p>
<ol>
<li>Make one object that looks like you want. You can just clone the base <code>Object</code> built into the system and then add whatever properties you want.</li>
<li>Clone it to make as many&hellip; uh&hellip; clones as you want.</li>
</ol>
<p>This gives us the cleverness of the Prototype design pattern without the headache of having to implement <code>clone()</code> ourselves. It&#x2019;s just built into the system.</p>
<p>This is such a beautiful, clever, minimal system that as soon as I learned about this, <span name="finch">I started building</span> an interpreter for a prototype-based language just to get more experience with it. A minimal but complete prototype-based language is much simpler than an equally minimal class-based one.</p>
<aside name="finch">

<p>I realize building one from scratch is not the most efficient way to learn, but what can I say, I&#x2019;m a bit peculiar. If you&#x2019;re curious, the language is called <a href="http://finch.stuffwithstuff.com/">Finch</a>.</p>
</aside>

<h3><a href="#how-did-it-go" name="how-did-it-go">How did it go?</a></h3>
<p>I was super excited to play with a pure prototype-based language, but once I had mine up and running, I <span name="no-fun">discovered</span> an unpleasant fact: it just wasn&#x2019;t that fun to program in.</p>
<aside name="no-fun">

<p>I&#x2019;ve since heard through the grapevine that many of the Self programmers came to the same conclusion. The project was far from a loss, though. Self was so dynamic that it needed all sorts of virtual machine innovations in order to run fast enough.</p>
<p>The ideas they came up with in Self for just-in-time compilation, garbage collection, and optimizing method dispatch are the exact same techniques (often implemented by the same people!) that now make many of the world&#x2019;s dynamically-typed languages faster than they&#x2019;ve ever been.</p>
</aside>

<p>Sure, the language was simple, but that was because it punted the complexity onto the user. As soon as I started trying to use it, the first thing I did was try to come up with a pattern for defining classes.</p>
<p>My hunch is that most people just like well-defined "kinds of things". In addition to the runaway success of classes-based languages, look at how many games have character classes, and a precise roster of different sorts of enemies, items, and skills, each neatly labelled. We love baseball cards and stamp collecting. You don&#x2019;t see many games where each monster is a unique snowflake, like "sort of halfway between a troll and a goblin with a bit of snake mixed in".</p>
<p>While prototypes are a really really cool paradigm, and one that I wish more people knew about, I&#x2019;m glad that most of us aren&#x2019;t actually programming using them every day. The code I&#x2019;ve seen that really tries to fully embrace prototypes has a weird mushiness to it that I find really hard to work with.</p>
<h3><a href="#what-about-javascript" name="what-about-javascript">What about JavaScript?</a></h3>
<p>Readers who know what&#x2019;s what are ready to pounce now. If prototype-based languages are so unfriendly, explain JavaScript: a language with prototypes that&#x2019;s used by millions of people every day. More computers run JavaScript than any other language on Earth.</p>
<p><span name="ten">Brendan Eich</span>, the creator of JavaScript, took inspiration directly from Self, and many of its internal semantics are prototype-based. Each object can have an arbitrary set of properties, both fields and "methods" (which are really just functions stored as fields). Every object can also have another object (called its "prototype") that it delegates to if a field access fails.</p>
<aside name="ten">

<p>When I said you can implement a prototype-based language more quickly than a class-based one, I meant it: Eich famously got the first version of JavaScript out the door in ten days.</p>
</aside>

<p>But, despite that, I will argue is that using JavaScript in practice is more like using a class-based language than a prototype-based one.</p>
<p>One hint that JavaScript has taken steps away from Self is that the core operation in a prototype-based language, cloning, is nowhere to be seen. There is no method to clone an object (create a new object with the same properties) in JavaScript.</p>
<p>The closest it has is <code>Object.create</code> which lets you create a new object that delegates to an existing one. That wasn&#x2019;t added until ECMAScript 5 a few years ago well after JavaScript was established, and it isn&#x2019;t commonly used.</p>
<p>Instead, let me walk you through the typical way you define and create types of objects in JavaScript. You start with a <em>constructor function</em>:</p>
<div class="codehilite"><pre><span class="kd">function</span> <span class="nx">Weapon</span><span class="p">(</span><span class="nx">range</span><span class="p">,</span> <span class="nx">damage</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">range</span> <span class="o">=</span> <span class="nx">range</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">damage</span> <span class="o">=</span> <span class="nx">damage</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>This creates a new object and initializes its fields. You invoke it like:</p>
<div class="codehilite"><pre><span class="kd">var</span> <span class="nx">sword</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Weapon</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</pre></div>


<p>The <code>new</code> here creates a new, empty object, then invokes the body of the <code>Weapon</code> function with <code>this</code> bound to that object. The body adds a bunch of fields to it, then it&#x2019;s implicitly returned. So now we&#x2019;ve got a little object with some state.</p>
<p>The <code>new</code> also does one other thing for you. When it creates that blank object, it automatically wires it up to a prototype object. You can access that object using <code>Weapon.prototype</code>.</p>
<p><strong>TODO: whoa this needs some illustrations</strong></p>
<p>To define behavior, you usually add methods to that prototype object. So we could do something like this:</p>
<div class="codehilite"><pre><span class="nx">Weapon</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">attack</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">distanceTo</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">range</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Out of range!&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">target</span><span class="p">.</span><span class="nx">health</span> <span class="o">-=</span> <span class="k">this</span><span class="p">.</span><span class="nx">damage</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Since every object returned by <code>new Weapon()</code> delegates to <code>Weapon.prototype</code>, you can now call <code>sword.attack()</code> and it will call that function. So here we&#x2019;ve got:</p>
<ul>
<li>
<p>The way you create objects is by a "new" operation that you invoke on an object that represents the type (the constructor function).</p>
</li>
<li>
<p>State is stored on the instance itself.</p>
</li>
<li>
<p>Behavior goes through a level of indirection and is stored on a separate object that represents the set of methods shared by all objects of a certain type.</p>
</li>
</ul>
<p>Call me crazy, but that sounds a lot like my description of classes above. Yes, you <em>can</em> write prototype-style code in JavaScript (sort of, without cloning), but the syntax and idioms of the language encourage a much more class-based approach.</p>
<p>Personally, I think that&#x2019;s a <span name="good">good thing</span>. Like I&#x2019;ve said, I think doubling down on prototypes actually makes code harder to work with, so I like that JavaScript wraps the core semantics in something a little more structured and "classy".</p>
<aside name="good">

<p>Others in the JS community disagree vehemently. There are strong forces pulling JavaScript to evolve both towards and away from classes and it will be interesting to see which way it goes in the next few years.</p>
</aside>

<h2><a href="#prototypes-for-data-modeling" name="prototypes-for-data-modeling">Prototypes for Data Modeling</a></h2>
<p>OK, I keep talking about things I <em>don&#x2019;t</em> like prototypes for, which is making this chapter a real downer. Everybody likes a happy ending, so let&#x2019;s close this out with an area where I <em>do</em> think prototypes, or more specifically <em>delegation</em>, are a good fit.</p>
<p>If you were to count up all the bytes in a game that are code versus ones that are data, you&#x2019;d see the ratio of data to code has been increasingly steadily pretty much since day one. Where early games procedurally generated almost everything and had next to no data, today, we typically think of a game codebase as an "engine" that just runs the game itself which is defined entirely in data.</p>
<p>That&#x2019;s great, but just having piles of data doesn&#x2019;t magically solve all of our organizational problems. Programming languages make our jobs easier because they provide lots features that let us get rid of duplication in our code.</p>
<p>Instead of having to copy and paste a chunk of code in a bunch of places, we move it into a function that we can refer to by name and call. Instead of copying a method in a bunch of classes, we can put it in a separate class that those classes inherit from or mixin.</p>
<p>When your game&#x2019;s data reaches a certain size, you really start wanting similar features. Data modelling is a deep subject that I couldn&#x2019;t hope to do justice here, but I do want to throw out one feature for you to consider in your own games: using prototypes and delegation for reusing data.</p>
<p>Lets say we&#x2019;re defining the data model for the shameless Gauntlet rip-off I mentioned earlier. The game designers need to be able to specify the attributes for monsters and items in some kind of file.</p>
<p>One common approach is to use JSON: data entities are basically <em>maps</em>, or <em>property bags</em> or any of a dozen other terms because there&#x2019;s nothing programmers like more than inventing names for stuff that already exists.</p>
<p>So a goblin in the game might be defined something like:</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>


<p>This is pretty straightforward and even the most text-averse designer can handle that. So you throw in a couple more kinds of monsters:</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin wizard&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">],</span>
  <span class="nt">&quot;spells&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire ball&quot;</span><span class="p">,</span> <span class="s2">&quot;lightning bolt&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin archer&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">],</span>
  <span class="nt">&quot;attacks&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;short bow&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>


<p>Now, if this was code, our aesthetic sense would be tingling now. There&#x2019;s a lot of duplication between these entities, and well-trained programmers <em>hate</em> redundancy. It wastes space and takes more time to author. More importantly, it&#x2019;s a maintenance headache. If we decide to make all of the goblins in the game stronger, we need to remember to update the health of all three of these.</p>
<p>If this was code, we&#x2019;d create an abstraction for a "goblin" and reuse that across the three goblin types. But dumb JSON doesn&#x2019;t know anything about that. So let&#x2019;s make it a bit smarter. We&#x2019;ll add a little meta-programming (metadata?) facility to these bags of properties.</p>
<p>If an object has an <code>&amp;#x2019;prototype&amp;#x2019;</code> field, then that defines the name of some other object that this one is derived from. We&#x2019;ll copy over any fields from that prototype object into the new one. In other words, the new object is a clone of that one, then with modifications applied.</p>
<p>With that, we can simplify our goblin horde to:</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;minHealth&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="nt">&quot;maxHealth&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nt">&quot;resists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cold&quot;</span><span class="p">,</span> <span class="s2">&quot;poison&quot;</span><span class="p">],</span>
  <span class="nt">&quot;weaknesses&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire&quot;</span><span class="p">,</span> <span class="s2">&quot;light&quot;</span><span class="p">],</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin wizard&quot;</span><span class="p">,</span>
  <span class="nt">&quot;prototype&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;spells&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;fire ball&quot;</span><span class="p">,</span> <span class="s2">&quot;lightning bolt&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin archer&quot;</span><span class="p">,</span>
  <span class="nt">&quot;prototype&quot;</span><span class="p">:</span> <span class="s2">&quot;goblin grunt&quot;</span><span class="p">,</span>
  <span class="nt">&quot;attacks&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;short bow&quot;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>


<p>Since the archer and wizard have the grunt as their prototype, we don&#x2019;t have to repeat the health, resists and weaknesses in each of them. The semantics we&#x2019;ve added to our data model is super simple, just basic delegation, but we&#x2019;ve already gotten rid of a bunch of duplication.</p>
<p>One interesting thing to note here is that we didn&#x2019;t set up a separate "base goblin" abstract prototype for the three concrete goblin types to delegate to. Instead, we just picked one of the goblins who was the simplest and delegate to that.</p>
<p>That feels natural in a prototype-based system where any object can be used as a clone to create new refined objects, and I think it&#x2019;s equally natural here too. It&#x2019;s a particularly good fit for data in games where you often have one-off special entities in the game world.</p>
<p>Think bosses and unique items. These are often refinements of a more common object in the game, and prototypal delegation is a good fit for defining those. The magic Sword of Head-Detaching, which is really just a longsword with some bonuses can be expressed as that directly:</p>
<div class="codehilite"><pre><span class="p">{</span>
  <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Sword of Head-Detaching&quot;</span><span class="p">,</span>
  <span class="nt">&quot;prototype&quot;</span><span class="p">:</span> <span class="s2">&quot;sword&quot;</span><span class="p">,</span>
  <span class="nt">&quot;damage-bonus&quot;</span><span class="p">:</span> <span class="s2">&quot;20d8&quot;</span>
<span class="p">}</span>
</pre></div>


<p>A little extra power in your game engine&#x2019;s data modelling system can make it easier for designers to add lots of little variations to the armaments and beastiers populating your game world, and that richness is exactly what delights players.</p>
<p class="footer">&copy; 2009-2013 Bob Nystrom</p>
</div>
</body>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</html>
